{"version":3,"file":"static/js/npm.data.f5b18f5b.js","mappings":"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","sources":["../node_modules/@tanstack/query-core/src/mutation.ts","../node_modules/@tanstack/query-core/src/onlineManager.ts","../node_modules/@tanstack/query-core/src/logger.ts","../node_modules/@tanstack/query-core/src/subscribable.ts","../node_modules/@tanstack/query-core/src/focusManager.ts","../node_modules/@tanstack/query-core/src/mutationObserver.ts","../node_modules/@tanstack/react-query/src/useMutation.ts","../node_modules/@tanstack/react-query/src/utils.ts","../node_modules/@tanstack/query-core/src/queryObserver.ts","../node_modules/@tanstack/react-query/src/QueryErrorResetBoundary.tsx","../node_modules/@tanstack/react-query/src/isRestoring.tsx","../node_modules/@tanstack/react-query/src/errorBoundaryUtils.ts","../node_modules/@tanstack/react-query/src/suspense.ts","../node_modules/@tanstack/react-query/src/useQuery.ts","../node_modules/@tanstack/react-query/src/useBaseQuery.ts","../node_modules/axios/lib/helpers/bind.js","../node_modules/axios/lib/utils.js","../node_modules/axios/lib/core/AxiosError.js","../node_modules/axios/lib/helpers/toFormData.js","../node_modules/axios/lib/helpers/AxiosURLSearchParams.js","../node_modules/axios/lib/helpers/buildURL.js","../node_modules/axios/lib/core/InterceptorManager.js","../node_modules/axios/lib/defaults/transitional.js","../node_modules/axios/lib/platform/browser/classes/URLSearchParams.js","../node_modules/axios/lib/platform/browser/index.js","../node_modules/axios/lib/platform/browser/classes/FormData.js","../node_modules/axios/lib/platform/browser/classes/Blob.js","../node_modules/axios/lib/platform/common/utils.js","../node_modules/axios/lib/platform/index.js","../node_modules/axios/lib/helpers/formDataToJSON.js","../node_modules/axios/lib/defaults/index.js","../node_modules/axios/lib/helpers/toURLEncodedForm.js","../node_modules/axios/lib/helpers/parseHeaders.js","../node_modules/axios/lib/core/AxiosHeaders.js","../node_modules/axios/lib/core/transformData.js","../node_modules/axios/lib/cancel/isCancel.js","../node_modules/axios/lib/cancel/CanceledError.js","../node_modules/axios/lib/core/settle.js","../node_modules/axios/lib/helpers/speedometer.js","../node_modules/axios/lib/helpers/throttle.js","../node_modules/axios/lib/helpers/progressEventReducer.js","../node_modules/axios/lib/helpers/isURLSameOrigin.js","../node_modules/axios/lib/helpers/cookies.js","../node_modules/axios/lib/core/buildFullPath.js","../node_modules/axios/lib/helpers/isAbsoluteURL.js","../node_modules/axios/lib/helpers/combineURLs.js","../node_modules/axios/lib/core/mergeConfig.js","../node_modules/axios/lib/helpers/resolveConfig.js","../node_modules/axios/lib/adapters/xhr.js","../node_modules/axios/lib/helpers/parseProtocol.js","../node_modules/axios/lib/helpers/composeSignals.js","../node_modules/axios/lib/helpers/trackStream.js","../node_modules/axios/lib/adapters/fetch.js","../node_modules/axios/lib/adapters/adapters.js","../node_modules/axios/lib/helpers/null.js","../node_modules/axios/lib/core/dispatchRequest.js","../node_modules/axios/lib/env/data.js","../node_modules/axios/lib/helpers/validator.js","../node_modules/axios/lib/core/Axios.js","../node_modules/axios/lib/cancel/CancelToken.js","../node_modules/axios/lib/helpers/HttpStatusCode.js","../node_modules/axios/lib/axios.js","../node_modules/axios/lib/helpers/spread.js","../node_modules/axios/lib/helpers/isAxiosError.js","../node_modules/@tanstack/query-core/src/query.ts","../node_modules/@tanstack/query-core/src/queryCache.ts","../node_modules/@tanstack/query-core/src/mutationCache.ts","../node_modules/@tanstack/query-core/src/infiniteQueryBehavior.ts","../node_modules/@tanstack/query-core/src/queryClient.ts","../node_modules/@tanstack/query-core/src/removable.ts","../node_modules/@tanstack/query-core/src/retryer.ts","../node_modules/@tanstack/query-core/src/utils.ts","../node_modules/@tanstack/react-query/src/useSyncExternalStore.ts","../node_modules/@tanstack/react-query/src/QueryClientProvider.tsx","../node_modules/@tanstack/query-core/src/notifyManager.ts"],"sourcesContent":["import { defaultLogger } from './logger'\nimport { notifyManager } from './notifyManager'\nimport { Removable } from './removable'\nimport { canFetch, createRetryer } from './retryer'\nimport type { MutationMeta, MutationOptions, MutationStatus } from './types'\nimport type { MutationCache } from './mutationCache'\nimport type { MutationObserver } from './mutationObserver'\nimport type { Logger } from './logger'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface MutationConfig<TData, TError, TVariables, TContext> {\n  mutationId: number\n  mutationCache: MutationCache\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  logger?: Logger\n  defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>\n  state?: MutationState<TData, TError, TVariables, TContext>\n  meta?: MutationMeta\n}\n\nexport interface MutationState<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> {\n  context: TContext | undefined\n  data: TData | undefined\n  error: TError | null\n  failureCount: number\n  failureReason: TError | null\n  isPaused: boolean\n  status: MutationStatus\n  variables: TVariables | undefined\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError | null\n}\n\ninterface LoadingAction<TVariables, TContext> {\n  type: 'loading'\n  variables?: TVariables\n  context?: TContext\n}\n\ninterface SuccessAction<TData> {\n  type: 'success'\n  data: TData\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError, TVariables, TContext> {\n  type: 'setState'\n  state: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport type Action<TData, TError, TVariables, TContext> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | LoadingAction<TVariables, TContext>\n  | PauseAction\n  | SetStateAction<TData, TError, TVariables, TContext>\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Mutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> extends Removable {\n  state: MutationState<TData, TError, TVariables, TContext>\n  options!: MutationOptions<TData, TError, TVariables, TContext>\n  mutationId: number\n\n  private observers: MutationObserver<TData, TError, TVariables, TContext>[]\n  private defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>\n  private mutationCache: MutationCache\n  private logger: Logger\n  private retryer?: Retryer<TData>\n\n  constructor(config: MutationConfig<TData, TError, TVariables, TContext>) {\n    super()\n\n    this.defaultOptions = config.defaultOptions\n    this.mutationId = config.mutationId\n    this.mutationCache = config.mutationCache\n    this.logger = config.logger || defaultLogger\n    this.observers = []\n    this.state = config.state || getDefaultState()\n\n    this.setOptions(config.options)\n    this.scheduleGc()\n  }\n\n  setOptions(\n    options?: MutationOptions<TData, TError, TVariables, TContext>,\n  ): void {\n    this.options = { ...this.defaultOptions, ...options }\n\n    this.updateCacheTime(this.options.cacheTime)\n  }\n\n  get meta(): MutationMeta | undefined {\n    return this.options.meta\n  }\n\n  setState(state: MutationState<TData, TError, TVariables, TContext>): void {\n    this.dispatch({ type: 'setState', state })\n  }\n\n  addObserver(observer: MutationObserver<any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the mutation from being garbage collected\n      this.clearGcTimeout()\n\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer,\n      })\n    }\n  }\n\n  removeObserver(observer: MutationObserver<any, any, any, any>): void {\n    this.observers = this.observers.filter((x) => x !== observer)\n\n    this.scheduleGc()\n\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer,\n    })\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc()\n      } else {\n        this.mutationCache.remove(this)\n      }\n    }\n  }\n\n  continue(): Promise<unknown> {\n    return this.retryer?.continue() ?? this.execute()\n  }\n\n  async execute(): Promise<TData> {\n    const executeMutation = () => {\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found')\n          }\n          return this.options.mutationFn(this.state.variables!)\n        },\n        onFail: (failureCount, error) => {\n          this.dispatch({ type: 'failed', failureCount, error })\n        },\n        onPause: () => {\n          this.dispatch({ type: 'pause' })\n        },\n        onContinue: () => {\n          this.dispatch({ type: 'continue' })\n        },\n        retry: this.options.retry ?? 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode,\n      })\n\n      return this.retryer.promise\n    }\n\n    const restored = this.state.status === 'loading'\n    try {\n      if (!restored) {\n        this.dispatch({ type: 'loading', variables: this.options.variables! })\n        // Notify cache callback\n        await this.mutationCache.config.onMutate?.(\n          this.state.variables,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n        const context = await this.options.onMutate?.(this.state.variables!)\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables,\n          })\n        }\n      }\n      const data = await executeMutation()\n\n      // Notify cache callback\n      await this.mutationCache.config.onSuccess?.(\n        data,\n        this.state.variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSuccess?.(\n        data,\n        this.state.variables!,\n        this.state.context!,\n      )\n\n      // Notify cache callback\n      await this.mutationCache.config.onSettled?.(\n        data,\n        null,\n        this.state.variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSettled?.(\n        data,\n        null,\n        this.state.variables!,\n        this.state.context,\n      )\n\n      this.dispatch({ type: 'success', data })\n      return data\n    } catch (error) {\n      try {\n        // Notify cache callback\n        await this.mutationCache.config.onError?.(\n          error,\n          this.state.variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error)\n        }\n\n        await this.options.onError?.(\n          error as TError,\n          this.state.variables!,\n          this.state.context,\n        )\n\n        // Notify cache callback\n        await this.mutationCache.config.onSettled?.(\n          undefined,\n          error,\n          this.state.variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        await this.options.onSettled?.(\n          undefined,\n          error as TError,\n          this.state.variables!,\n          this.state.context,\n        )\n        throw error\n      } finally {\n        this.dispatch({ type: 'error', error: error as TError })\n      }\n    }\n  }\n\n  private dispatch(action: Action<TData, TError, TVariables, TContext>): void {\n    const reducer = (\n      state: MutationState<TData, TError, TVariables, TContext>,\n    ): MutationState<TData, TError, TVariables, TContext> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            isPaused: true,\n          }\n        case 'continue':\n          return {\n            ...state,\n            isPaused: false,\n          }\n        case 'loading':\n          return {\n            ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables,\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false,\n          }\n        case 'error':\n          return {\n            ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error',\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onMutationUpdate(action)\n      })\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action,\n      })\n    })\n  }\n}\n\nexport function getDefaultState<\n  TData,\n  TError,\n  TVariables,\n  TContext,\n>(): MutationState<TData, TError, TVariables, TContext> {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined,\n  }\n}\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setOnline: (online?: boolean) => void,\n) => (() => void) | undefined\n\nconst onlineEvents = ['online', 'offline'] as const\n\nexport class OnlineManager extends Subscribable {\n  private online?: boolean\n  private cleanup?: () => void\n\n  private setup: SetupFn\n\n  constructor() {\n    super()\n    this.setup = (onOnline) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline()\n        // Listen to online\n        onlineEvents.forEach((event) => {\n          window.addEventListener(event, listener, false)\n        })\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          onlineEvents.forEach((event) => {\n            window.removeEventListener(event, listener)\n          })\n        }\n      }\n\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.cleanup?.()\n      this.cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.setup = setup\n    this.cleanup?.()\n    this.cleanup = setup((online?: boolean) => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online)\n      } else {\n        this.onOnline()\n      }\n    })\n  }\n\n  setOnline(online?: boolean): void {\n    const changed = this.online !== online\n\n    if (changed) {\n      this.online = online\n      this.onOnline()\n    }\n  }\n\n  onOnline(): void {\n    this.listeners.forEach(({ listener }) => {\n      listener()\n    })\n  }\n\n  isOnline(): boolean {\n    if (typeof this.online === 'boolean') {\n      return this.online\n    }\n\n    if (\n      typeof navigator === 'undefined' ||\n      typeof navigator.onLine === 'undefined'\n    ) {\n      return true\n    }\n\n    return navigator.onLine\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n","export interface Logger {\n  log: LogFunction\n  warn: LogFunction\n  error: LogFunction\n}\n\ntype LogFunction = (...args: any[]) => void\n\nexport const defaultLogger: Logger = console\n","type Listener = () => void\n\nexport class Subscribable<TListener extends Function = Listener> {\n  protected listeners: Set<{ listener: TListener }>\n\n  constructor() {\n    this.listeners = new Set()\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  subscribe(listener: TListener): () => void {\n    const identity = { listener }\n    this.listeners.add(identity)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners.delete(identity)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.size > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setFocused: (focused?: boolean) => void,\n) => (() => void) | undefined\n\nexport class FocusManager extends Subscribable {\n  private focused?: boolean\n  private cleanup?: () => void\n\n  private setup: SetupFn\n\n  constructor() {\n    super()\n    this.setup = (onFocus) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus()\n        // Listen to visibillitychange and focus\n        window.addEventListener('visibilitychange', listener, false)\n        window.addEventListener('focus', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener)\n          window.removeEventListener('focus', listener)\n        }\n      }\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.cleanup?.()\n      this.cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.setup = setup\n    this.cleanup?.()\n    this.cleanup = setup((focused) => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    const changed = this.focused !== focused\n    if (changed) {\n      this.focused = focused\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    this.listeners.forEach(({ listener }) => {\n      listener()\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.focused === 'boolean') {\n      return this.focused\n    }\n\n    // document global can be unavailable in react native\n    if (typeof document === 'undefined') {\n      return true\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(\n      document.visibilityState,\n    )\n  }\n}\n\nexport const focusManager = new FocusManager()\n","import { getDefaultState } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport { shallowEqualObjects } from './utils'\nimport type { QueryClient } from './queryClient'\nimport type {\n  MutateOptions,\n  MutationObserverBaseResult,\n  MutationObserverOptions,\n  MutationObserverResult,\n} from './types'\nimport type { Action, Mutation } from './mutation'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>,\n) => void\n\ninterface NotifyOptions {\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  private client: QueryClient\n  private currentResult!: MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >\n  private currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  private mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    super()\n\n    this.client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options?: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    const prevOptions = this.options\n    this.options = this.client.defaultMutationOptions(options)\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.currentMutation,\n        observer: this,\n      })\n    }\n    this.currentMutation?.setOptions(this.options)\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.updateResult()\n\n    // Determine which callbacks to trigger\n    const notifyOptions: NotifyOptions = {\n      listeners: true,\n    }\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true\n    }\n\n    this.notify(notifyOptions)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.currentResult\n  }\n\n  reset(): void {\n    this.currentMutation = undefined\n    this.updateResult()\n    this.notify({ listeners: true })\n  }\n\n  mutate(\n    variables?: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>,\n  ): Promise<TData> {\n    this.mutateOptions = options\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this)\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, {\n      ...this.options,\n      variables:\n        typeof variables !== 'undefined' ? variables : this.options.variables,\n    })\n\n    this.currentMutation.addObserver(this)\n\n    return this.currentMutation.execute()\n  }\n\n  private updateResult(): void {\n    const state = this.currentMutation\n      ? this.currentMutation.state\n      : getDefaultState<TData, TError, TVariables, TContext>()\n\n    const isLoading = state.status === 'loading'\n    const result: MutationObserverBaseResult<\n      TData,\n      TError,\n      TVariables,\n      TContext\n    > = {\n      ...state,\n      isLoading,\n      isPending: isLoading,\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset,\n    }\n\n    this.currentResult = result as MutationObserverResult<\n      TData,\n      TError,\n      TVariables,\n      TContext\n    >\n  }\n\n  private notify(options: NotifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions && this.hasListeners()) {\n        if (options.onSuccess) {\n          this.mutateOptions.onSuccess?.(\n            this.currentResult.data!,\n            this.currentResult.variables!,\n            this.currentResult.context!,\n          )\n          this.mutateOptions.onSettled?.(\n            this.currentResult.data!,\n            null,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n        } else if (options.onError) {\n          this.mutateOptions.onError?.(\n            this.currentResult.error!,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n          this.mutateOptions.onSettled?.(\n            undefined,\n            this.currentResult.error,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      if (options.listeners) {\n        this.listeners.forEach(({ listener }) => {\n          listener(this.currentResult)\n        })\n      }\n    })\n  }\n}\n","'use client'\nimport * as React from 'react'\nimport {\n  MutationObserver,\n  notifyManager,\n  parseMutationArgs,\n} from '@tanstack/query-core'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport { useQueryClient } from './QueryClientProvider'\nimport { shouldThrowError } from './utils'\nimport type { MutationFunction, MutationKey } from '@tanstack/query-core'\nimport type {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationFn: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  mutationFn?: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey' | 'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MutationKey\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg2?:\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg3?: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const options = parseMutationArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        queryClient,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.useErrorBoundary, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n","export function shouldThrowError<T extends (...args: any[]) => boolean>(\n  _useErrorBoundary: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params)\n  }\n\n  return !!_useErrorBoundary\n}\n","import {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { focusManager } from './focusManager'\nimport { Subscribable } from './subscribable'\nimport { canFetch, isCancelledError } from './retryer'\nimport type {\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\nimport type { Action, FetchOptions, Query, QueryState } from './query'\nimport type { QueryClient } from './queryClient'\nimport type { DefaultedQueryObserverOptions, RefetchPageFilters } from './types'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\nexport interface NotifyOptions {\n  cache?: boolean\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\nexport interface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  options: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n\n  private client: QueryClient\n  private currentQuery!: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  private currentQueryInitialState!: QueryState<TQueryData, TError>\n  private currentResult!: QueryObserverResult<TData, TError>\n  private currentResultState?: QueryState<TQueryData, TError>\n  private currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  private previousQueryResult?: QueryObserverResult<TData, TError>\n  private selectError: TError | null\n  private selectFn?: (data: TQueryData) => TData\n  private selectResult?: TData\n  private staleTimeoutId?: ReturnType<typeof setTimeout>\n  private refetchIntervalId?: ReturnType<typeof setInterval>\n  private currentRefetchInterval?: number | false\n  private trackedProps!: Set<keyof QueryObserverResult>\n\n  constructor(\n    client: QueryClient,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.client = client\n    this.options = options\n    this.trackedProps = new Set()\n    this.selectError = null\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.remove = this.remove.bind(this)\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch()\n      }\n\n      this.updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.clearStaleTimeout()\n    this.clearRefetchInterval()\n    this.currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options?: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.currentQuery\n\n    this.options = this.client.defaultQueryOptions(options)\n\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      typeof options?.isDataEqual !== 'undefined'\n    ) {\n      this.client\n        .getLogger()\n        .error(\n          `The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option`,\n        )\n    }\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.currentQuery,\n        observer: this,\n      })\n    }\n\n    if (\n      typeof this.options.enabled !== 'undefined' &&\n      typeof this.options.enabled !== 'boolean'\n    ) {\n      throw new Error('Expected enabled to be a boolean')\n    }\n\n    // Keep previous query key if the user does not supply one\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey\n    }\n\n    this.updateQuery()\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.executeFetch()\n    }\n\n    // Update result\n    this.updateResult(notifyOptions)\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        this.options.staleTime !== prevOptions.staleTime)\n    ) {\n      this.updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        nextRefetchInterval !== this.currentRefetchInterval)\n    ) {\n      this.updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.client.getQueryCache().build(this.client, options)\n\n    const result = this.createResult(query, options)\n\n    if (shouldAssignObserverCurrentProperties(this, result, options)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult everytime\n      // an observer reads an optimistic value.\n\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.currentResult = result\n      this.currentResultOptions = this.options\n      this.currentResultState = this.currentQuery.state\n    }\n    return result\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n  ): QueryObserverResult<TData, TError> {\n    const trackedResult = {} as QueryObserverResult<TData, TError>\n\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key as keyof QueryObserverResult)\n          return result[key as keyof QueryObserverResult]\n        },\n      })\n    })\n\n    return trackedResult\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.currentQuery\n  }\n\n  remove(): void {\n    this.client.getQueryCache().remove(this.currentQuery)\n  }\n\n  refetch<TPageData>({\n    refetchPage,\n    ...options\n  }: RefetchOptions & RefetchPageFilters<TPageData> = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n      meta: { refetchPage },\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.client.defaultQueryOptions(options)\n\n    const query = this.client\n      .getQueryCache()\n      .build(this.client, defaultedOptions)\n    query.isFetchingOptimistic = true\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.currentResult\n    })\n  }\n\n  private executeFetch(\n    fetchOptions?: ObserverFetchOptions,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  private updateStaleTimeout(): void {\n    this.clearStaleTimeout()\n\n    if (\n      isServer ||\n      this.currentResult.isStale ||\n      !isValidTimeout(this.options.staleTime)\n    ) {\n      return\n    }\n\n    const time = timeUntilStale(\n      this.currentResult.dataUpdatedAt,\n      this.options.staleTime,\n    )\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  private computeRefetchInterval() {\n    return typeof this.options.refetchInterval === 'function'\n      ? this.options.refetchInterval(this.currentResult.data, this.currentQuery)\n      : this.options.refetchInterval ?? false\n  }\n\n  private updateRefetchInterval(nextInterval: number | false): void {\n    this.clearRefetchInterval()\n\n    this.currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      this.options.enabled === false ||\n      !isValidTimeout(this.currentRefetchInterval) ||\n      this.currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.executeFetch()\n      }\n    }, this.currentRefetchInterval)\n  }\n\n  private updateTimers(): void {\n    this.updateStaleTimeout()\n    this.updateRefetchInterval(this.computeRefetchInterval())\n  }\n\n  private clearStaleTimeout(): void {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId)\n      this.staleTimeoutId = undefined\n    }\n  }\n\n  private clearRefetchInterval(): void {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId)\n      this.refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.currentQuery\n    const prevOptions = this.options\n    const prevResult = this.currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.currentResultState\n    const prevResultOptions = this.currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.currentQueryInitialState\n    const prevQueryResult = queryChange\n      ? this.currentResult\n      : this.previousQueryResult\n\n    const { state } = query\n    let { dataUpdatedAt, error, errorUpdatedAt, fetchStatus, status } = state\n    let isPreviousData = false\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode)\n          ? 'fetching'\n          : 'paused'\n        if (!dataUpdatedAt) {\n          status = 'loading'\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle'\n      }\n    }\n\n    // Keep previous data if needed\n    if (\n      options.keepPreviousData &&\n      !state.dataUpdatedAt &&\n      prevQueryResult?.isSuccess &&\n      status !== 'error'\n    ) {\n      data = prevQueryResult.data\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt\n      status = prevQueryResult.status\n      isPreviousData = true\n    }\n    // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (\n        prevResult &&\n        state.data === prevResultState?.data &&\n        options.select === this.selectFn\n      ) {\n        data = this.selectResult\n      } else {\n        try {\n          this.selectFn = options.select\n          data = options.select(state.data)\n          data = replaceData(prevResult?.data, data, options)\n          this.selectResult = data\n          this.selectError = null\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError)\n          }\n          this.selectError = selectError as TError\n        }\n      }\n    }\n    // Use query data\n    else {\n      data = state.data as unknown as TData\n    }\n\n    // Show placeholder data if needed\n    if (\n      typeof options.placeholderData !== 'undefined' &&\n      typeof data === 'undefined' &&\n      status === 'loading'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n      } else {\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (options.placeholderData as PlaceholderDataFunction<TQueryData>)()\n            : options.placeholderData\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData)\n            this.selectError = null\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError)\n            }\n            this.selectError = selectError as TError\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success'\n        data = replaceData(prevResult?.data, placeholderData, options) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError as any\n      data = this.selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = fetchStatus === 'fetching'\n    const isLoading = status === 'loading'\n    const isError = status === 'error'\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus,\n      isLoading,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading && isFetching,\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        state.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isLoading,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove,\n    }\n\n    return result as QueryObserverResult<TData, TError>\n  }\n\n  updateResult(notifyOptions?: NotifyOptions): void {\n    const prevResult = this.currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.currentQuery, this.options)\n    this.currentResultState = this.currentQuery.state\n    this.currentResultOptions = this.options\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.currentResult = nextResult\n\n    // Determine which callbacks to trigger\n    const defaultNotifyOptions: NotifyOptions = { cache: true }\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n      const notifyOnChangePropsValue =\n        typeof notifyOnChangeProps === 'function'\n          ? notifyOnChangeProps()\n          : notifyOnChangeProps\n\n      if (\n        notifyOnChangePropsValue === 'all' ||\n        (!notifyOnChangePropsValue && !this.trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.trackedProps,\n      )\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey]\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true\n    }\n\n    this.notify({ ...defaultNotifyOptions, ...notifyOptions })\n  }\n\n  private updateQuery(): void {\n    const query = this.client.getQueryCache().build(this.client, this.options)\n\n    if (query === this.currentQuery) {\n      return\n    }\n\n    const prevQuery = this.currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.currentQuery = query\n    this.currentQueryInitialState = query.state\n    this.previousQueryResult = this.currentResult\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(action: Action<TData, TError>): void {\n    const notifyOptions: NotifyOptions = {}\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true\n    }\n\n    this.updateResult(notifyOptions)\n\n    if (this.hasListeners()) {\n      this.updateTimers()\n    }\n  }\n\n  private notify(notifyOptions: NotifyOptions): void {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        this.options.onSuccess?.(this.currentResult.data!)\n        this.options.onSettled?.(this.currentResult.data!, null)\n      } else if (notifyOptions.onError) {\n        this.options.onError?.(this.currentResult.error!)\n        this.options.onSettled?.(undefined, this.currentResult.error!)\n      }\n\n      // Then trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(({ listener }) => {\n          listener(this.currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated',\n        })\n      }\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    !query.state.dataUpdatedAt &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.dataUpdatedAt > 0 &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: typeof options['refetchOnMount'] &\n    typeof options['refetchOnWindowFocus'] &\n    typeof options['refetchOnReconnect'],\n) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    (query !== prevQuery || prevOptions.enabled === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return query.isStaleByTime(options.staleTime)\n}\n\n// this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\nfunction shouldAssignObserverCurrentProperties<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  optimisticResult: QueryObserverResult<TData, TError>,\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n) {\n  // it is important to keep this condition like this for three reasons:\n  // 1. It will get removed in the v5\n  // 2. it reads: don't update the properties if we want to keep the previous\n  // data.\n  // 3. The opposite condition (!options.keepPreviousData) would fallthrough\n  // and will result in a bad decision\n  if (options.keepPreviousData) {\n    return false\n  }\n\n  // this means we want to put some placeholder data when pending and queryKey\n  // changed.\n  if (options.placeholderData !== undefined) {\n    // re-assign properties only if current data is placeholder data\n    // which means that data did not arrive yet, so, if there is some cached data\n    // we need to \"prepare\" to receive it\n    return optimisticResult.isPlaceholderData\n  }\n\n  // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true\n  }\n\n  // basically, just keep previous properties if nothing changed\n  return false\n}\n","'use client'\nimport * as React from 'react'\n\n// CONTEXT\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: () => void\n  isReset: () => boolean\n  reset: () => void\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport interface QueryErrorResetBoundaryProps {\n  children:\n    | ((value: QueryErrorResetBoundaryValue) => React.ReactNode)\n    | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function'\n        ? (children as Function)(value)\n        : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n","'use client'\nimport * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n","'use client'\nimport * as React from 'react'\nimport { shouldThrowError } from './utils'\nimport type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  UseErrorBoundary,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const ensurePreventErrorBoundaryRetry = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  if (options.suspense || options.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false\n    }\n  }\n}\n\nexport const useClearResetErrorBoundary = (\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n}\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  errorResetBoundary,\n  useErrorBoundary,\n  query,\n}: {\n  result: QueryObserverResult<TData, TError>\n  errorResetBoundary: QueryErrorResetBoundaryValue\n  useErrorBoundary: UseErrorBoundary<\n    TQueryFnData,\n    TError,\n    TQueryData,\n    TQueryKey\n  >\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n}) => {\n  return (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    shouldThrowError(useErrorBoundary, [result.error, query])\n  )\n}\n","import type { DefaultedQueryObserverOptions } from '@tanstack/query-core'\nimport type { QueryObserver } from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\nimport type { QueryObserverResult } from '@tanstack/query-core'\nimport type { QueryKey } from '@tanstack/query-core'\n\nexport const ensureStaleTime = (\n  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,\n) => {\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000\n    }\n  }\n}\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => result.isLoading && result.isFetching && !isRestoring\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => defaultedOptions?.suspense && willFetch(result, isRestoring)\n\nexport const fetchOptimistic = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  defaultedOptions: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) =>\n  observer\n    .fetchOptimistic(defaultedOptions)\n    .then(({ data }) => {\n      defaultedOptions.onSuccess?.(data as TData)\n      defaultedOptions.onSettled?.(data, null)\n    })\n    .catch((error) => {\n      errorResetBoundary.clearReset()\n      defaultedOptions.onError?.(error)\n      defaultedOptions.onSettled?.(undefined, error)\n    })\n","'use client'\nimport { QueryObserver, parseQueryArgs } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type {\n  InitialDataFunction,\n  NonUndefinedGuard,\n  OmitKeyof,\n  QueryFunction,\n  QueryKey,\n} from '@tanstack/query-core'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\n\n// HOOK\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: OmitKeyof<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & {\n    initialData:\n      | NonUndefinedGuard<TQueryFnData>\n      | (() => NonUndefinedGuard<TQueryFnData>)\n  },\n): DefinedUseQueryResult<TData, TError>\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: OmitKeyof<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & {\n    initialData?:\n      | undefined\n      | InitialDataFunction<NonUndefinedGuard<TQueryFnData>>\n      | NonUndefinedGuard<TQueryFnData>\n  },\n): UseQueryResult<TData, TError>\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError>\n\n/** @deprecated */\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: OmitKeyof<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  >,\n): UseQueryResult<TData, TError>\n/** @deprecated */\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: OmitKeyof<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n/** @deprecated */\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: OmitKeyof<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey'\n  >,\n): UseQueryResult<TData, TError>\n/** @deprecated */\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: OmitKeyof<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n/** @deprecated */\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: OmitKeyof<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n/** @deprecated */\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: OmitKeyof<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn'\n  >,\n): UseQueryResult<TData, TError>\nexport function useQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg3?: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError> {\n  const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(parsedOptions, QueryObserver)\n}\n","'use client'\nimport * as React from 'react'\n\nimport { notifyManager } from '@tanstack/query-core'\nimport { useSyncExternalStore } from './useSyncExternalStore'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useIsRestoring } from './isRestoring'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport { ensureStaleTime, fetchOptimistic, shouldSuspend } from './suspense'\nimport type { QueryKey, QueryObserver } from '@tanstack/query-core'\nimport type { UseBaseQueryOptions } from './types'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n) {\n  const queryClient = useQueryClient({ context: options.context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  // Include callbacks in batch renders\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(\n      defaultedOptions.onError,\n    )\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(\n      defaultedOptions.onSuccess,\n    )\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(\n      defaultedOptions.onSettled,\n    )\n  }\n\n  ensureStaleTime(defaultedOptions)\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        queryClient,\n        defaultedOptions,\n      ),\n  )\n\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange))\n\n        // Update result to make sure we did not miss any query updates\n        // between creating the observer and subscribing to it.\n        observer.updateResult()\n\n        return unsubscribe\n      },\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, { listeners: false })\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (shouldSuspend(defaultedOptions, result, isRestoring)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      useErrorBoundary: defaultedOptions.useErrorBoundary,\n      query: observer.getCurrentQuery(),\n    })\n  ) {\n    throw result.error\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n","'use strict';\n\nexport default function bind(fn, thisArg) {\n  return function wrap() {\n    return fn.apply(thisArg, arguments);\n  };\n}\n","'use strict';\n\nimport bind from './helpers/bind.js';\n\n// utils is a library of generic helper functions non-specific to axios\n\nconst {toString} = Object.prototype;\nconst {getPrototypeOf} = Object;\nconst {iterator, toStringTag} = Symbol;\n\nconst kindOf = (cache => thing => {\n    const str = toString.call(thing);\n    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n})(Object.create(null));\n\nconst kindOfTest = (type) => {\n  type = type.toLowerCase();\n  return (thing) => kindOf(thing) === type\n}\n\nconst typeOfTest = type => thing => typeof thing === type;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n *\n * @returns {boolean} True if value is an Array, otherwise false\n */\nconst {isArray} = Array;\n\n/**\n * Determine if a value is undefined\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nconst isUndefined = typeOfTest('undefined');\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nconst isArrayBuffer = kindOfTest('ArrayBuffer');\n\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  let result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a String, otherwise false\n */\nconst isString = typeOfTest('string');\n\n/**\n * Determine if a value is a Function\n *\n * @param {*} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nconst isFunction = typeOfTest('function');\n\n/**\n * Determine if a value is a Number\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Number, otherwise false\n */\nconst isNumber = typeOfTest('number');\n\n/**\n * Determine if a value is an Object\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an Object, otherwise false\n */\nconst isObject = (thing) => thing !== null && typeof thing === 'object';\n\n/**\n * Determine if a value is a Boolean\n *\n * @param {*} thing The value to test\n * @returns {boolean} True if value is a Boolean, otherwise false\n */\nconst isBoolean = thing => thing === true || thing === false;\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a plain Object, otherwise false\n */\nconst isPlainObject = (val) => {\n  if (kindOf(val) !== 'object') {\n    return false;\n  }\n\n  const prototype = getPrototypeOf(val);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);\n}\n\n/**\n * Determine if a value is an empty object (safely handles Buffers)\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an empty object, otherwise false\n */\nconst isEmptyObject = (val) => {\n  // Early return for non-objects or Buffers to prevent RangeError\n  if (!isObject(val) || isBuffer(val)) {\n    return false;\n  }\n  \n  try {\n    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;\n  } catch (e) {\n    // Fallback for any other objects that might cause RangeError with Object.keys()\n    return false;\n  }\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Date, otherwise false\n */\nconst isDate = kindOfTest('Date');\n\n/**\n * Determine if a value is a File\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFile = kindOfTest('File');\n\n/**\n * Determine if a value is a Blob\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nconst isBlob = kindOfTest('Blob');\n\n/**\n * Determine if a value is a FileList\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFileList = kindOfTest('FileList');\n\n/**\n * Determine if a value is a Stream\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nconst isStream = (val) => isObject(val) && isFunction(val.pipe);\n\n/**\n * Determine if a value is a FormData\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nconst isFormData = (thing) => {\n  let kind;\n  return thing && (\n    (typeof FormData === 'function' && thing instanceof FormData) || (\n      isFunction(thing.append) && (\n        (kind = kindOf(thing)) === 'formdata' ||\n        // detect form-data instance\n        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')\n      )\n    )\n  )\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nconst isURLSearchParams = kindOfTest('URLSearchParams');\n\nconst [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n *\n * @returns {String} The String freed of excess whitespace\n */\nconst trim = (str) => str.trim ?\n  str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n *\n * @param {Boolean} [allOwnKeys = false]\n * @returns {any}\n */\nfunction forEach(obj, fn, {allOwnKeys = false} = {}) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  let i;\n  let l;\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Buffer check\n    if (isBuffer(obj)) {\n      return;\n    }\n\n    // Iterate over object keys\n    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);\n    const len = keys.length;\n    let key;\n\n    for (i = 0; i < len; i++) {\n      key = keys[i];\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n}\n\nfunction findKey(obj, key) {\n  if (isBuffer(obj)){\n    return null;\n  }\n\n  key = key.toLowerCase();\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let _key;\n  while (i-- > 0) {\n    _key = keys[i];\n    if (key === _key.toLowerCase()) {\n      return _key;\n    }\n  }\n  return null;\n}\n\nconst _global = (() => {\n  /*eslint no-undef:0*/\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  return typeof self !== \"undefined\" ? self : (typeof window !== 'undefined' ? window : global)\n})();\n\nconst isContextDefined = (context) => !isUndefined(context) && context !== _global;\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n *\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  const {caseless} = isContextDefined(this) && this || {};\n  const result = {};\n  const assignValue = (val, key) => {\n    const targetKey = caseless && findKey(result, key) || key;\n    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {\n      result[targetKey] = merge(result[targetKey], val);\n    } else if (isPlainObject(val)) {\n      result[targetKey] = merge({}, val);\n    } else if (isArray(val)) {\n      result[targetKey] = val.slice();\n    } else {\n      result[targetKey] = val;\n    }\n  }\n\n  for (let i = 0, l = arguments.length; i < l; i++) {\n    arguments[i] && forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n *\n * @param {Boolean} [allOwnKeys]\n * @returns {Object} The resulting value of object a\n */\nconst extend = (a, b, thisArg, {allOwnKeys}= {}) => {\n  forEach(b, (val, key) => {\n    if (thisArg && isFunction(val)) {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  }, {allOwnKeys});\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n *\n * @returns {string} content value without BOM\n */\nconst stripBOM = (content) => {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n *\n * @returns {void}\n */\nconst inherits = (constructor, superConstructor, props, descriptors) => {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  Object.defineProperty(constructor, 'super', {\n    value: superConstructor.prototype\n  });\n  props && Object.assign(constructor.prototype, props);\n}\n\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function|Boolean} [filter]\n * @param {Function} [propFilter]\n *\n * @returns {Object}\n */\nconst toFlatObject = (sourceObj, destObj, filter, propFilter) => {\n  let props;\n  let i;\n  let prop;\n  const merged = {};\n\n  destObj = destObj || {};\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  if (sourceObj == null) return destObj;\n\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n    while (i-- > 0) {\n      prop = props[i];\n      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n    sourceObj = filter !== false && getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n\n  return destObj;\n}\n\n/**\n * Determines whether a string ends with the characters of a specified string\n *\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n *\n * @returns {boolean}\n */\nconst endsWith = (str, searchString, position) => {\n  str = String(str);\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n  position -= searchString.length;\n  const lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n}\n\n\n/**\n * Returns new array from array like object or null if failed\n *\n * @param {*} [thing]\n *\n * @returns {?Array}\n */\nconst toArray = (thing) => {\n  if (!thing) return null;\n  if (isArray(thing)) return thing;\n  let i = thing.length;\n  if (!isNumber(i)) return null;\n  const arr = new Array(i);\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n  return arr;\n}\n\n/**\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\n * thing passed in is an instance of Uint8Array\n *\n * @param {TypedArray}\n *\n * @returns {Array}\n */\n// eslint-disable-next-line func-names\nconst isTypedArray = (TypedArray => {\n  // eslint-disable-next-line func-names\n  return thing => {\n    return TypedArray && thing instanceof TypedArray;\n  };\n})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));\n\n/**\n * For each entry in the object, call the function with the key and value.\n *\n * @param {Object<any, any>} obj - The object to iterate over.\n * @param {Function} fn - The function to call for each entry.\n *\n * @returns {void}\n */\nconst forEachEntry = (obj, fn) => {\n  const generator = obj && obj[iterator];\n\n  const _iterator = generator.call(obj);\n\n  let result;\n\n  while ((result = _iterator.next()) && !result.done) {\n    const pair = result.value;\n    fn.call(obj, pair[0], pair[1]);\n  }\n}\n\n/**\n * It takes a regular expression and a string, and returns an array of all the matches\n *\n * @param {string} regExp - The regular expression to match against.\n * @param {string} str - The string to search.\n *\n * @returns {Array<boolean>}\n */\nconst matchAll = (regExp, str) => {\n  let matches;\n  const arr = [];\n\n  while ((matches = regExp.exec(str)) !== null) {\n    arr.push(matches);\n  }\n\n  return arr;\n}\n\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */\nconst isHTMLForm = kindOfTest('HTMLFormElement');\n\nconst toCamelCase = str => {\n  return str.toLowerCase().replace(/[-_\\s]([a-z\\d])(\\w*)/g,\n    function replacer(m, p1, p2) {\n      return p1.toUpperCase() + p2;\n    }\n  );\n};\n\n/* Creating a function that will check if an object has a property. */\nconst hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);\n\n/**\n * Determine if a value is a RegExp object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a RegExp object, otherwise false\n */\nconst isRegExp = kindOfTest('RegExp');\n\nconst reduceDescriptors = (obj, reducer) => {\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  const reducedDescriptors = {};\n\n  forEach(descriptors, (descriptor, name) => {\n    let ret;\n    if ((ret = reducer(descriptor, name, obj)) !== false) {\n      reducedDescriptors[name] = ret || descriptor;\n    }\n  });\n\n  Object.defineProperties(obj, reducedDescriptors);\n}\n\n/**\n * Makes all methods read-only\n * @param {Object} obj\n */\n\nconst freezeMethods = (obj) => {\n  reduceDescriptors(obj, (descriptor, name) => {\n    // skip restricted props in strict mode\n    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {\n      return false;\n    }\n\n    const value = obj[name];\n\n    if (!isFunction(value)) return;\n\n    descriptor.enumerable = false;\n\n    if ('writable' in descriptor) {\n      descriptor.writable = false;\n      return;\n    }\n\n    if (!descriptor.set) {\n      descriptor.set = () => {\n        throw Error('Can not rewrite read-only method \\'' + name + '\\'');\n      };\n    }\n  });\n}\n\nconst toObjectSet = (arrayOrString, delimiter) => {\n  const obj = {};\n\n  const define = (arr) => {\n    arr.forEach(value => {\n      obj[value] = true;\n    });\n  }\n\n  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));\n\n  return obj;\n}\n\nconst noop = () => {}\n\nconst toFiniteNumber = (value, defaultValue) => {\n  return value != null && Number.isFinite(value = +value) ? value : defaultValue;\n}\n\n/**\n * If the thing is a FormData object, return true, otherwise return false.\n *\n * @param {unknown} thing - The thing to check.\n *\n * @returns {boolean}\n */\nfunction isSpecCompliantForm(thing) {\n  return !!(thing && isFunction(thing.append) && thing[toStringTag] === 'FormData' && thing[iterator]);\n}\n\nconst toJSONObject = (obj) => {\n  const stack = new Array(10);\n\n  const visit = (source, i) => {\n\n    if (isObject(source)) {\n      if (stack.indexOf(source) >= 0) {\n        return;\n      }\n\n      //Buffer check\n      if (isBuffer(source)) {\n        return source;\n      }\n\n      if(!('toJSON' in source)) {\n        stack[i] = source;\n        const target = isArray(source) ? [] : {};\n\n        forEach(source, (value, key) => {\n          const reducedValue = visit(value, i + 1);\n          !isUndefined(reducedValue) && (target[key] = reducedValue);\n        });\n\n        stack[i] = undefined;\n\n        return target;\n      }\n    }\n\n    return source;\n  }\n\n  return visit(obj, 0);\n}\n\nconst isAsyncFn = kindOfTest('AsyncFunction');\n\nconst isThenable = (thing) =>\n  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);\n\n// original code\n// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34\n\nconst _setImmediate = ((setImmediateSupported, postMessageSupported) => {\n  if (setImmediateSupported) {\n    return setImmediate;\n  }\n\n  return postMessageSupported ? ((token, callbacks) => {\n    _global.addEventListener(\"message\", ({source, data}) => {\n      if (source === _global && data === token) {\n        callbacks.length && callbacks.shift()();\n      }\n    }, false);\n\n    return (cb) => {\n      callbacks.push(cb);\n      _global.postMessage(token, \"*\");\n    }\n  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);\n})(\n  typeof setImmediate === 'function',\n  isFunction(_global.postMessage)\n);\n\nconst asap = typeof queueMicrotask !== 'undefined' ?\n  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);\n\n// *********************\n\n\nconst isIterable = (thing) => thing != null && isFunction(thing[iterator]);\n\n\nexport default {\n  isArray,\n  isArrayBuffer,\n  isBuffer,\n  isFormData,\n  isArrayBufferView,\n  isString,\n  isNumber,\n  isBoolean,\n  isObject,\n  isPlainObject,\n  isEmptyObject,\n  isReadableStream,\n  isRequest,\n  isResponse,\n  isHeaders,\n  isUndefined,\n  isDate,\n  isFile,\n  isBlob,\n  isRegExp,\n  isFunction,\n  isStream,\n  isURLSearchParams,\n  isTypedArray,\n  isFileList,\n  forEach,\n  merge,\n  extend,\n  trim,\n  stripBOM,\n  inherits,\n  toFlatObject,\n  kindOf,\n  kindOfTest,\n  endsWith,\n  toArray,\n  forEachEntry,\n  matchAll,\n  isHTMLForm,\n  hasOwnProperty,\n  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection\n  reduceDescriptors,\n  freezeMethods,\n  toObjectSet,\n  toCamelCase,\n  noop,\n  toFiniteNumber,\n  findKey,\n  global: _global,\n  isContextDefined,\n  isSpecCompliantForm,\n  toJSONObject,\n  isAsyncFn,\n  isThenable,\n  setImmediate: _setImmediate,\n  asap,\n  isIterable\n};\n","'use strict';\n\nimport utils from '../utils.js';\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [config] The config.\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n *\n * @returns {Error} The created error.\n */\nfunction AxiosError(message, code, config, request, response) {\n  Error.call(this);\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n  this.message = message;\n  this.name = 'AxiosError';\n  code && (this.code = code);\n  config && (this.config = config);\n  request && (this.request = request);\n  if (response) {\n    this.response = response;\n    this.status = response.status ? response.status : null;\n  }\n}\n\nutils.inherits(AxiosError, Error, {\n  toJSON: function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: utils.toJSONObject(this.config),\n      code: this.code,\n      status: this.status\n    };\n  }\n});\n\nconst prototype = AxiosError.prototype;\nconst descriptors = {};\n\n[\n  'ERR_BAD_OPTION_VALUE',\n  'ERR_BAD_OPTION',\n  'ECONNABORTED',\n  'ETIMEDOUT',\n  'ERR_NETWORK',\n  'ERR_FR_TOO_MANY_REDIRECTS',\n  'ERR_DEPRECATED',\n  'ERR_BAD_RESPONSE',\n  'ERR_BAD_REQUEST',\n  'ERR_CANCELED',\n  'ERR_NOT_SUPPORT',\n  'ERR_INVALID_URL'\n// eslint-disable-next-line func-names\n].forEach(code => {\n  descriptors[code] = {value: code};\n});\n\nObject.defineProperties(AxiosError, descriptors);\nObject.defineProperty(prototype, 'isAxiosError', {value: true});\n\n// eslint-disable-next-line func-names\nAxiosError.from = (error, code, config, request, response, customProps) => {\n  const axiosError = Object.create(prototype);\n\n  utils.toFlatObject(error, axiosError, function filter(obj) {\n    return obj !== Error.prototype;\n  }, prop => {\n    return prop !== 'isAxiosError';\n  });\n\n  AxiosError.call(axiosError, error.message, code, config, request, response);\n\n  axiosError.cause = error;\n\n  axiosError.name = error.name;\n\n  customProps && Object.assign(axiosError, customProps);\n\n  return axiosError;\n};\n\nexport default AxiosError;\n","'use strict';\n\nimport utils from '../utils.js';\nimport AxiosError from '../core/AxiosError.js';\n// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored\nimport PlatformFormData from '../platform/node/classes/FormData.js';\n\n/**\n * Determines if the given thing is a array or js object.\n *\n * @param {string} thing - The object or array to be visited.\n *\n * @returns {boolean}\n */\nfunction isVisitable(thing) {\n  return utils.isPlainObject(thing) || utils.isArray(thing);\n}\n\n/**\n * It removes the brackets from the end of a string\n *\n * @param {string} key - The key of the parameter.\n *\n * @returns {string} the key without the brackets.\n */\nfunction removeBrackets(key) {\n  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;\n}\n\n/**\n * It takes a path, a key, and a boolean, and returns a string\n *\n * @param {string} path - The path to the current key.\n * @param {string} key - The key of the current object being iterated over.\n * @param {string} dots - If true, the key will be rendered with dots instead of brackets.\n *\n * @returns {string} The path to the current key.\n */\nfunction renderKey(path, key, dots) {\n  if (!path) return key;\n  return path.concat(key).map(function each(token, i) {\n    // eslint-disable-next-line no-param-reassign\n    token = removeBrackets(token);\n    return !dots && i ? '[' + token + ']' : token;\n  }).join(dots ? '.' : '');\n}\n\n/**\n * If the array is an array and none of its elements are visitable, then it's a flat array.\n *\n * @param {Array<any>} arr - The array to check\n *\n * @returns {boolean}\n */\nfunction isFlatArray(arr) {\n  return utils.isArray(arr) && !arr.some(isVisitable);\n}\n\nconst predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {\n  return /^is[A-Z]/.test(prop);\n});\n\n/**\n * Convert a data object to FormData\n *\n * @param {Object} obj\n * @param {?Object} [formData]\n * @param {?Object} [options]\n * @param {Function} [options.visitor]\n * @param {Boolean} [options.metaTokens = true]\n * @param {Boolean} [options.dots = false]\n * @param {?Boolean} [options.indexes = false]\n *\n * @returns {Object}\n **/\n\n/**\n * It converts an object into a FormData object\n *\n * @param {Object<any, any>} obj - The object to convert to form data.\n * @param {string} formData - The FormData object to append to.\n * @param {Object<string, any>} options\n *\n * @returns\n */\nfunction toFormData(obj, formData, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('target must be an object');\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  formData = formData || new (PlatformFormData || FormData)();\n\n  // eslint-disable-next-line no-param-reassign\n  options = utils.toFlatObject(options, {\n    metaTokens: true,\n    dots: false,\n    indexes: false\n  }, false, function defined(option, source) {\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    return !utils.isUndefined(source[option]);\n  });\n\n  const metaTokens = options.metaTokens;\n  // eslint-disable-next-line no-use-before-define\n  const visitor = options.visitor || defaultVisitor;\n  const dots = options.dots;\n  const indexes = options.indexes;\n  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;\n  const useBlob = _Blob && utils.isSpecCompliantForm(formData);\n\n  if (!utils.isFunction(visitor)) {\n    throw new TypeError('visitor must be a function');\n  }\n\n  function convertValue(value) {\n    if (value === null) return '';\n\n    if (utils.isDate(value)) {\n      return value.toISOString();\n    }\n\n    if (utils.isBoolean(value)) {\n      return value.toString();\n    }\n\n    if (!useBlob && utils.isBlob(value)) {\n      throw new AxiosError('Blob is not supported. Use a Buffer instead.');\n    }\n\n    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {\n      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);\n    }\n\n    return value;\n  }\n\n  /**\n   * Default visitor.\n   *\n   * @param {*} value\n   * @param {String|Number} key\n   * @param {Array<String|Number>} path\n   * @this {FormData}\n   *\n   * @returns {boolean} return true to visit the each prop of the value recursively\n   */\n  function defaultVisitor(value, key, path) {\n    let arr = value;\n\n    if (value && !path && typeof value === 'object') {\n      if (utils.endsWith(key, '{}')) {\n        // eslint-disable-next-line no-param-reassign\n        key = metaTokens ? key : key.slice(0, -2);\n        // eslint-disable-next-line no-param-reassign\n        value = JSON.stringify(value);\n      } else if (\n        (utils.isArray(value) && isFlatArray(value)) ||\n        ((utils.isFileList(value) || utils.endsWith(key, '[]')) && (arr = utils.toArray(value))\n        )) {\n        // eslint-disable-next-line no-param-reassign\n        key = removeBrackets(key);\n\n        arr.forEach(function each(el, index) {\n          !(utils.isUndefined(el) || el === null) && formData.append(\n            // eslint-disable-next-line no-nested-ternary\n            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),\n            convertValue(el)\n          );\n        });\n        return false;\n      }\n    }\n\n    if (isVisitable(value)) {\n      return true;\n    }\n\n    formData.append(renderKey(path, key, dots), convertValue(value));\n\n    return false;\n  }\n\n  const stack = [];\n\n  const exposedHelpers = Object.assign(predicates, {\n    defaultVisitor,\n    convertValue,\n    isVisitable\n  });\n\n  function build(value, path) {\n    if (utils.isUndefined(value)) return;\n\n    if (stack.indexOf(value) !== -1) {\n      throw Error('Circular reference detected in ' + path.join('.'));\n    }\n\n    stack.push(value);\n\n    utils.forEach(value, function each(el, key) {\n      const result = !(utils.isUndefined(el) || el === null) && visitor.call(\n        formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers\n      );\n\n      if (result === true) {\n        build(el, path ? path.concat(key) : [key]);\n      }\n    });\n\n    stack.pop();\n  }\n\n  if (!utils.isObject(obj)) {\n    throw new TypeError('data must be an object');\n  }\n\n  build(obj);\n\n  return formData;\n}\n\nexport default toFormData;\n","'use strict';\n\nimport toFormData from './toFormData.js';\n\n/**\n * It encodes a string by replacing all characters that are not in the unreserved set with\n * their percent-encoded equivalents\n *\n * @param {string} str - The string to encode.\n *\n * @returns {string} The encoded string.\n */\nfunction encode(str) {\n  const charMap = {\n    '!': '%21',\n    \"'\": '%27',\n    '(': '%28',\n    ')': '%29',\n    '~': '%7E',\n    '%20': '+',\n    '%00': '\\x00'\n  };\n  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {\n    return charMap[match];\n  });\n}\n\n/**\n * It takes a params object and converts it to a FormData object\n *\n * @param {Object<string, any>} params - The parameters to be converted to a FormData object.\n * @param {Object<string, any>} options - The options object passed to the Axios constructor.\n *\n * @returns {void}\n */\nfunction AxiosURLSearchParams(params, options) {\n  this._pairs = [];\n\n  params && toFormData(params, this, options);\n}\n\nconst prototype = AxiosURLSearchParams.prototype;\n\nprototype.append = function append(name, value) {\n  this._pairs.push([name, value]);\n};\n\nprototype.toString = function toString(encoder) {\n  const _encode = encoder ? function(value) {\n    return encoder.call(this, value, encode);\n  } : encode;\n\n  return this._pairs.map(function each(pair) {\n    return _encode(pair[0]) + '=' + _encode(pair[1]);\n  }, '').join('&');\n};\n\nexport default AxiosURLSearchParams;\n","'use strict';\n\nimport utils from '../utils.js';\nimport AxiosURLSearchParams from '../helpers/AxiosURLSearchParams.js';\n\n/**\n * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their\n * URI encoded counterparts\n *\n * @param {string} val The value to be encoded.\n *\n * @returns {string} The encoded value.\n */\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @param {?(object|Function)} options\n *\n * @returns {string} The formatted url\n */\nexport default function buildURL(url, params, options) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n  \n  const _encode = options && options.encode || encode;\n\n  if (utils.isFunction(options)) {\n    options = {\n      serialize: options\n    };\n  } \n\n  const serializeFn = options && options.serialize;\n\n  let serializedParams;\n\n  if (serializeFn) {\n    serializedParams = serializeFn(params, options);\n  } else {\n    serializedParams = utils.isURLSearchParams(params) ?\n      params.toString() :\n      new AxiosURLSearchParams(params, options).toString(_encode);\n  }\n\n  if (serializedParams) {\n    const hashmarkIndex = url.indexOf(\"#\");\n\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n}\n","'use strict';\n\nimport utils from './../utils.js';\n\nclass InterceptorManager {\n  constructor() {\n    this.handlers = [];\n  }\n\n  /**\n   * Add a new interceptor to the stack\n   *\n   * @param {Function} fulfilled The function to handle `then` for a `Promise`\n   * @param {Function} rejected The function to handle `reject` for a `Promise`\n   *\n   * @return {Number} An ID used to remove interceptor later\n   */\n  use(fulfilled, rejected, options) {\n    this.handlers.push({\n      fulfilled,\n      rejected,\n      synchronous: options ? options.synchronous : false,\n      runWhen: options ? options.runWhen : null\n    });\n    return this.handlers.length - 1;\n  }\n\n  /**\n   * Remove an interceptor from the stack\n   *\n   * @param {Number} id The ID that was returned by `use`\n   *\n   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise\n   */\n  eject(id) {\n    if (this.handlers[id]) {\n      this.handlers[id] = null;\n    }\n  }\n\n  /**\n   * Clear all interceptors from the stack\n   *\n   * @returns {void}\n   */\n  clear() {\n    if (this.handlers) {\n      this.handlers = [];\n    }\n  }\n\n  /**\n   * Iterate over all the registered interceptors\n   *\n   * This method is particularly useful for skipping over any\n   * interceptors that may have become `null` calling `eject`.\n   *\n   * @param {Function} fn The function to call for each interceptor\n   *\n   * @returns {void}\n   */\n  forEach(fn) {\n    utils.forEach(this.handlers, function forEachHandler(h) {\n      if (h !== null) {\n        fn(h);\n      }\n    });\n  }\n}\n\nexport default InterceptorManager;\n","'use strict';\n\nexport default {\n  silentJSONParsing: true,\n  forcedJSONParsing: true,\n  clarifyTimeoutError: false\n};\n","'use strict';\n\nimport AxiosURLSearchParams from '../../../helpers/AxiosURLSearchParams.js';\nexport default typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;\n","import URLSearchParams from './classes/URLSearchParams.js'\nimport FormData from './classes/FormData.js'\nimport Blob from './classes/Blob.js'\n\nexport default {\n  isBrowser: true,\n  classes: {\n    URLSearchParams,\n    FormData,\n    Blob\n  },\n  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']\n};\n","'use strict';\n\nexport default typeof FormData !== 'undefined' ? FormData : null;\n","'use strict'\n\nexport default typeof Blob !== 'undefined' ? Blob : null\n","const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';\n\nconst _navigator = typeof navigator === 'object' && navigator || undefined;\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n *\n * @returns {boolean}\n */\nconst hasStandardBrowserEnv = hasBrowserEnv &&\n  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);\n\n/**\n * Determine if we're running in a standard browser webWorker environment\n *\n * Although the `isStandardBrowserEnv` method indicates that\n * `allows axios to run in a web worker`, the WebWorker will still be\n * filtered out due to its judgment standard\n * `typeof window !== 'undefined' && typeof document !== 'undefined'`.\n * This leads to a problem when axios post `FormData` in webWorker\n */\nconst hasStandardBrowserWebWorkerEnv = (() => {\n  return (\n    typeof WorkerGlobalScope !== 'undefined' &&\n    // eslint-disable-next-line no-undef\n    self instanceof WorkerGlobalScope &&\n    typeof self.importScripts === 'function'\n  );\n})();\n\nconst origin = hasBrowserEnv && window.location.href || 'http://localhost';\n\nexport {\n  hasBrowserEnv,\n  hasStandardBrowserWebWorkerEnv,\n  hasStandardBrowserEnv,\n  _navigator as navigator,\n  origin\n}\n","import platform from './node/index.js';\nimport * as utils from './common/utils.js';\n\nexport default {\n  ...utils,\n  ...platform\n}\n","'use strict';\n\nimport utils from '../utils.js';\n\n/**\n * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']\n *\n * @param {string} name - The name of the property to get.\n *\n * @returns An array of strings.\n */\nfunction parsePropPath(name) {\n  // foo[x][y][z]\n  // foo.x.y.z\n  // foo-x-y-z\n  // foo x y z\n  return utils.matchAll(/\\w+|\\[(\\w*)]/g, name).map(match => {\n    return match[0] === '[]' ? '' : match[1] || match[0];\n  });\n}\n\n/**\n * Convert an array to an object.\n *\n * @param {Array<any>} arr - The array to convert to an object.\n *\n * @returns An object with the same keys and values as the array.\n */\nfunction arrayToObject(arr) {\n  const obj = {};\n  const keys = Object.keys(arr);\n  let i;\n  const len = keys.length;\n  let key;\n  for (i = 0; i < len; i++) {\n    key = keys[i];\n    obj[key] = arr[key];\n  }\n  return obj;\n}\n\n/**\n * It takes a FormData object and returns a JavaScript object\n *\n * @param {string} formData The FormData object to convert to JSON.\n *\n * @returns {Object<string, any> | null} The converted object.\n */\nfunction formDataToJSON(formData) {\n  function buildPath(path, value, target, index) {\n    let name = path[index++];\n\n    if (name === '__proto__') return true;\n\n    const isNumericKey = Number.isFinite(+name);\n    const isLast = index >= path.length;\n    name = !name && utils.isArray(target) ? target.length : name;\n\n    if (isLast) {\n      if (utils.hasOwnProp(target, name)) {\n        target[name] = [target[name], value];\n      } else {\n        target[name] = value;\n      }\n\n      return !isNumericKey;\n    }\n\n    if (!target[name] || !utils.isObject(target[name])) {\n      target[name] = [];\n    }\n\n    const result = buildPath(path, value, target[name], index);\n\n    if (result && utils.isArray(target[name])) {\n      target[name] = arrayToObject(target[name]);\n    }\n\n    return !isNumericKey;\n  }\n\n  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {\n    const obj = {};\n\n    utils.forEachEntry(formData, (name, value) => {\n      buildPath(parsePropPath(name), value, obj, 0);\n    });\n\n    return obj;\n  }\n\n  return null;\n}\n\nexport default formDataToJSON;\n","'use strict';\n\nimport utils from '../utils.js';\nimport AxiosError from '../core/AxiosError.js';\nimport transitionalDefaults from './transitional.js';\nimport toFormData from '../helpers/toFormData.js';\nimport toURLEncodedForm from '../helpers/toURLEncodedForm.js';\nimport platform from '../platform/index.js';\nimport formDataToJSON from '../helpers/formDataToJSON.js';\n\n/**\n * It takes a string, tries to parse it, and if it fails, it returns the stringified version\n * of the input\n *\n * @param {any} rawValue - The value to be stringified.\n * @param {Function} parser - A function that parses a string into a JavaScript object.\n * @param {Function} encoder - A function that takes a value and returns a string.\n *\n * @returns {string} A stringified version of the rawValue.\n */\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nconst defaults = {\n\n  transitional: transitionalDefaults,\n\n  adapter: ['xhr', 'http', 'fetch'],\n\n  transformRequest: [function transformRequest(data, headers) {\n    const contentType = headers.getContentType() || '';\n    const hasJSONContentType = contentType.indexOf('application/json') > -1;\n    const isObjectPayload = utils.isObject(data);\n\n    if (isObjectPayload && utils.isHTMLForm(data)) {\n      data = new FormData(data);\n    }\n\n    const isFormData = utils.isFormData(data);\n\n    if (isFormData) {\n      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;\n    }\n\n    if (utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data) ||\n      utils.isReadableStream(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);\n      return data.toString();\n    }\n\n    let isFileList;\n\n    if (isObjectPayload) {\n      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {\n        return toURLEncodedForm(data, this.formSerializer).toString();\n      }\n\n      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {\n        const _FormData = this.env && this.env.FormData;\n\n        return toFormData(\n          isFileList ? {'files[]': data} : data,\n          _FormData && new _FormData(),\n          this.formSerializer\n        );\n      }\n    }\n\n    if (isObjectPayload || hasJSONContentType ) {\n      headers.setContentType('application/json', false);\n      return stringifySafely(data);\n    }\n\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    const transitional = this.transitional || defaults.transitional;\n    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    const JSONRequested = this.responseType === 'json';\n\n    if (utils.isResponse(data) || utils.isReadableStream(data)) {\n      return data;\n    }\n\n    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {\n      const silentJSONParsing = transitional && transitional.silentJSONParsing;\n      const strictJSONParsing = !silentJSONParsing && JSONRequested;\n\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  env: {\n    FormData: platform.classes.FormData,\n    Blob: platform.classes.Blob\n  },\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*',\n      'Content-Type': undefined\n    }\n  }\n};\n\nutils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {\n  defaults.headers[method] = {};\n});\n\nexport default defaults;\n","'use strict';\n\nimport utils from '../utils.js';\nimport toFormData from './toFormData.js';\nimport platform from '../platform/index.js';\n\nexport default function toURLEncodedForm(data, options) {\n  return toFormData(data, new platform.classes.URLSearchParams(), {\n    visitor: function(value, key, path, helpers) {\n      if (platform.isNode && utils.isBuffer(value)) {\n        this.append(key, value.toString('base64'));\n        return false;\n      }\n\n      return helpers.defaultVisitor.apply(this, arguments);\n    },\n    ...options\n  });\n}\n","'use strict';\n\nimport utils from './../utils.js';\n\n// RawAxiosHeaders whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nconst ignoreDuplicateOf = utils.toObjectSet([\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n]);\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} rawHeaders Headers needing to be parsed\n *\n * @returns {Object} Headers parsed into an object\n */\nexport default rawHeaders => {\n  const parsed = {};\n  let key;\n  let val;\n  let i;\n\n  rawHeaders && rawHeaders.split('\\n').forEach(function parser(line) {\n    i = line.indexOf(':');\n    key = line.substring(0, i).trim().toLowerCase();\n    val = line.substring(i + 1).trim();\n\n    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {\n      return;\n    }\n\n    if (key === 'set-cookie') {\n      if (parsed[key]) {\n        parsed[key].push(val);\n      } else {\n        parsed[key] = [val];\n      }\n    } else {\n      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n    }\n  });\n\n  return parsed;\n};\n","'use strict';\n\nimport utils from '../utils.js';\nimport parseHeaders from '../helpers/parseHeaders.js';\n\nconst $internals = Symbol('internals');\n\nfunction normalizeHeader(header) {\n  return header && String(header).trim().toLowerCase();\n}\n\nfunction normalizeValue(value) {\n  if (value === false || value == null) {\n    return value;\n  }\n\n  return utils.isArray(value) ? value.map(normalizeValue) : String(value);\n}\n\nfunction parseTokens(str) {\n  const tokens = Object.create(null);\n  const tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  let match;\n\n  while ((match = tokensRE.exec(str))) {\n    tokens[match[1]] = match[2];\n  }\n\n  return tokens;\n}\n\nconst isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());\n\nfunction matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {\n  if (utils.isFunction(filter)) {\n    return filter.call(this, value, header);\n  }\n\n  if (isHeaderNameFilter) {\n    value = header;\n  }\n\n  if (!utils.isString(value)) return;\n\n  if (utils.isString(filter)) {\n    return value.indexOf(filter) !== -1;\n  }\n\n  if (utils.isRegExp(filter)) {\n    return filter.test(value);\n  }\n}\n\nfunction formatHeader(header) {\n  return header.trim()\n    .toLowerCase().replace(/([a-z\\d])(\\w*)/g, (w, char, str) => {\n      return char.toUpperCase() + str;\n    });\n}\n\nfunction buildAccessors(obj, header) {\n  const accessorName = utils.toCamelCase(' ' + header);\n\n  ['get', 'set', 'has'].forEach(methodName => {\n    Object.defineProperty(obj, methodName + accessorName, {\n      value: function(arg1, arg2, arg3) {\n        return this[methodName].call(this, header, arg1, arg2, arg3);\n      },\n      configurable: true\n    });\n  });\n}\n\nclass AxiosHeaders {\n  constructor(headers) {\n    headers && this.set(headers);\n  }\n\n  set(header, valueOrRewrite, rewrite) {\n    const self = this;\n\n    function setHeader(_value, _header, _rewrite) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!lHeader) {\n        throw new Error('header name must be a non-empty string');\n      }\n\n      const key = utils.findKey(self, lHeader);\n\n      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {\n        self[key || _header] = normalizeValue(_value);\n      }\n    }\n\n    const setHeaders = (headers, _rewrite) =>\n      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));\n\n    if (utils.isPlainObject(header) || header instanceof this.constructor) {\n      setHeaders(header, valueOrRewrite)\n    } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {\n      setHeaders(parseHeaders(header), valueOrRewrite);\n    } else if (utils.isObject(header) && utils.isIterable(header)) {\n      let obj = {}, dest, key;\n      for (const entry of header) {\n        if (!utils.isArray(entry)) {\n          throw TypeError('Object iterator must return a key-value pair');\n        }\n\n        obj[key = entry[0]] = (dest = obj[key]) ?\n          (utils.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]]) : entry[1];\n      }\n\n      setHeaders(obj, valueOrRewrite)\n    } else {\n      header != null && setHeader(valueOrRewrite, header, rewrite);\n    }\n\n    return this;\n  }\n\n  get(header, parser) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      if (key) {\n        const value = this[key];\n\n        if (!parser) {\n          return value;\n        }\n\n        if (parser === true) {\n          return parseTokens(value);\n        }\n\n        if (utils.isFunction(parser)) {\n          return parser.call(this, value, key);\n        }\n\n        if (utils.isRegExp(parser)) {\n          return parser.exec(value);\n        }\n\n        throw new TypeError('parser must be boolean|regexp|function');\n      }\n    }\n  }\n\n  has(header, matcher) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n    }\n\n    return false;\n  }\n\n  delete(header, matcher) {\n    const self = this;\n    let deleted = false;\n\n    function deleteHeader(_header) {\n      _header = normalizeHeader(_header);\n\n      if (_header) {\n        const key = utils.findKey(self, _header);\n\n        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {\n          delete self[key];\n\n          deleted = true;\n        }\n      }\n    }\n\n    if (utils.isArray(header)) {\n      header.forEach(deleteHeader);\n    } else {\n      deleteHeader(header);\n    }\n\n    return deleted;\n  }\n\n  clear(matcher) {\n    const keys = Object.keys(this);\n    let i = keys.length;\n    let deleted = false;\n\n    while (i--) {\n      const key = keys[i];\n      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {\n        delete this[key];\n        deleted = true;\n      }\n    }\n\n    return deleted;\n  }\n\n  normalize(format) {\n    const self = this;\n    const headers = {};\n\n    utils.forEach(this, (value, header) => {\n      const key = utils.findKey(headers, header);\n\n      if (key) {\n        self[key] = normalizeValue(value);\n        delete self[header];\n        return;\n      }\n\n      const normalized = format ? formatHeader(header) : String(header).trim();\n\n      if (normalized !== header) {\n        delete self[header];\n      }\n\n      self[normalized] = normalizeValue(value);\n\n      headers[normalized] = true;\n    });\n\n    return this;\n  }\n\n  concat(...targets) {\n    return this.constructor.concat(this, ...targets);\n  }\n\n  toJSON(asStrings) {\n    const obj = Object.create(null);\n\n    utils.forEach(this, (value, header) => {\n      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);\n    });\n\n    return obj;\n  }\n\n  [Symbol.iterator]() {\n    return Object.entries(this.toJSON())[Symbol.iterator]();\n  }\n\n  toString() {\n    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\\n');\n  }\n\n  getSetCookie() {\n    return this.get(\"set-cookie\") || [];\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'AxiosHeaders';\n  }\n\n  static from(thing) {\n    return thing instanceof this ? thing : new this(thing);\n  }\n\n  static concat(first, ...targets) {\n    const computed = new this(first);\n\n    targets.forEach((target) => computed.set(target));\n\n    return computed;\n  }\n\n  static accessor(header) {\n    const internals = this[$internals] = (this[$internals] = {\n      accessors: {}\n    });\n\n    const accessors = internals.accessors;\n    const prototype = this.prototype;\n\n    function defineAccessor(_header) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!accessors[lHeader]) {\n        buildAccessors(prototype, _header);\n        accessors[lHeader] = true;\n      }\n    }\n\n    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n\n    return this;\n  }\n}\n\nAxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);\n\n// reserved names hotfix\nutils.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {\n  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`\n  return {\n    get: () => value,\n    set(headerValue) {\n      this[mapped] = headerValue;\n    }\n  }\n});\n\nutils.freezeMethods(AxiosHeaders);\n\nexport default AxiosHeaders;\n","'use strict';\n\nimport utils from './../utils.js';\nimport defaults from '../defaults/index.js';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Array|Function} fns A single function or Array of functions\n * @param {?Object} response The response object\n *\n * @returns {*} The resulting transformed data\n */\nexport default function transformData(fns, response) {\n  const config = this || defaults;\n  const context = response || config;\n  const headers = AxiosHeaders.from(context.headers);\n  let data = context.data;\n\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);\n  });\n\n  headers.normalize();\n\n  return data;\n}\n","'use strict';\n\nexport default function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n}\n","'use strict';\n\nimport AxiosError from '../core/AxiosError.js';\nimport utils from '../utils.js';\n\n/**\n * A `CanceledError` is an object that is thrown when an operation is canceled.\n *\n * @param {string=} message The message.\n * @param {Object=} config The config.\n * @param {Object=} request The request.\n *\n * @returns {CanceledError} The created error.\n */\nfunction CanceledError(message, config, request) {\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);\n  this.name = 'CanceledError';\n}\n\nutils.inherits(CanceledError, AxiosError, {\n  __CANCEL__: true\n});\n\nexport default CanceledError;\n","'use strict';\n\nimport AxiosError from './AxiosError.js';\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n *\n * @returns {object} The response.\n */\nexport default function settle(resolve, reject, response) {\n  const validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(new AxiosError(\n      'Request failed with status code ' + response.status,\n      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],\n      response.config,\n      response.request,\n      response\n    ));\n  }\n}\n","'use strict';\n\n/**\n * Calculate data maxRate\n * @param {Number} [samplesCount= 10]\n * @param {Number} [min= 1000]\n * @returns {Function}\n */\nfunction speedometer(samplesCount, min) {\n  samplesCount = samplesCount || 10;\n  const bytes = new Array(samplesCount);\n  const timestamps = new Array(samplesCount);\n  let head = 0;\n  let tail = 0;\n  let firstSampleTS;\n\n  min = min !== undefined ? min : 1000;\n\n  return function push(chunkLength) {\n    const now = Date.now();\n\n    const startedAt = timestamps[tail];\n\n    if (!firstSampleTS) {\n      firstSampleTS = now;\n    }\n\n    bytes[head] = chunkLength;\n    timestamps[head] = now;\n\n    let i = tail;\n    let bytesCount = 0;\n\n    while (i !== head) {\n      bytesCount += bytes[i++];\n      i = i % samplesCount;\n    }\n\n    head = (head + 1) % samplesCount;\n\n    if (head === tail) {\n      tail = (tail + 1) % samplesCount;\n    }\n\n    if (now - firstSampleTS < min) {\n      return;\n    }\n\n    const passed = startedAt && now - startedAt;\n\n    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;\n  };\n}\n\nexport default speedometer;\n","/**\n * Throttle decorator\n * @param {Function} fn\n * @param {Number} freq\n * @return {Function}\n */\nfunction throttle(fn, freq) {\n  let timestamp = 0;\n  let threshold = 1000 / freq;\n  let lastArgs;\n  let timer;\n\n  const invoke = (args, now = Date.now()) => {\n    timestamp = now;\n    lastArgs = null;\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n    fn(...args);\n  }\n\n  const throttled = (...args) => {\n    const now = Date.now();\n    const passed = now - timestamp;\n    if ( passed >= threshold) {\n      invoke(args, now);\n    } else {\n      lastArgs = args;\n      if (!timer) {\n        timer = setTimeout(() => {\n          timer = null;\n          invoke(lastArgs)\n        }, threshold - passed);\n      }\n    }\n  }\n\n  const flush = () => lastArgs && invoke(lastArgs);\n\n  return [throttled, flush];\n}\n\nexport default throttle;\n","import speedometer from \"./speedometer.js\";\nimport throttle from \"./throttle.js\";\nimport utils from \"../utils.js\";\n\nexport const progressEventReducer = (listener, isDownloadStream, freq = 3) => {\n  let bytesNotified = 0;\n  const _speedometer = speedometer(50, 250);\n\n  return throttle(e => {\n    const loaded = e.loaded;\n    const total = e.lengthComputable ? e.total : undefined;\n    const progressBytes = loaded - bytesNotified;\n    const rate = _speedometer(progressBytes);\n    const inRange = loaded <= total;\n\n    bytesNotified = loaded;\n\n    const data = {\n      loaded,\n      total,\n      progress: total ? (loaded / total) : undefined,\n      bytes: progressBytes,\n      rate: rate ? rate : undefined,\n      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,\n      event: e,\n      lengthComputable: total != null,\n      [isDownloadStream ? 'download' : 'upload']: true\n    };\n\n    listener(data);\n  }, freq);\n}\n\nexport const progressEventDecorator = (total, throttled) => {\n  const lengthComputable = total != null;\n\n  return [(loaded) => throttled[0]({\n    lengthComputable,\n    total,\n    loaded\n  }), throttled[1]];\n}\n\nexport const asyncDecorator = (fn) => (...args) => utils.asap(() => fn(...args));\n","import platform from '../platform/index.js';\n\nexport default platform.hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {\n  url = new URL(url, platform.origin);\n\n  return (\n    origin.protocol === url.protocol &&\n    origin.host === url.host &&\n    (isMSIE || origin.port === url.port)\n  );\n})(\n  new URL(platform.origin),\n  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)\n) : () => true;\n","import utils from './../utils.js';\nimport platform from '../platform/index.js';\n\nexport default platform.hasStandardBrowserEnv ?\n\n  // Standard browser envs support document.cookie\n  {\n    write(name, value, expires, path, domain, secure) {\n      const cookie = [name + '=' + encodeURIComponent(value)];\n\n      utils.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());\n\n      utils.isString(path) && cookie.push('path=' + path);\n\n      utils.isString(domain) && cookie.push('domain=' + domain);\n\n      secure === true && cookie.push('secure');\n\n      document.cookie = cookie.join('; ');\n    },\n\n    read(name) {\n      const match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n      return (match ? decodeURIComponent(match[3]) : null);\n    },\n\n    remove(name) {\n      this.write(name, '', Date.now() - 86400000);\n    }\n  }\n\n  :\n\n  // Non-standard browser env (web workers, react-native) lack needed support.\n  {\n    write() {},\n    read() {\n      return null;\n    },\n    remove() {}\n  };\n\n","'use strict';\n\nimport isAbsoluteURL from '../helpers/isAbsoluteURL.js';\nimport combineURLs from '../helpers/combineURLs.js';\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n *\n * @returns {string} The combined full path\n */\nexport default function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {\n  let isRelativeUrl = !isAbsoluteURL(requestedURL);\n  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n}\n","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n *\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nexport default function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\n","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n *\n * @returns {string} The combined URL\n */\nexport default function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/?\\/$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n}\n","'use strict';\n\nimport utils from '../utils.js';\nimport AxiosHeaders from \"./AxiosHeaders.js\";\n\nconst headersToObject = (thing) => thing instanceof AxiosHeaders ? { ...thing } : thing;\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n *\n * @returns {Object} New object resulting from merging config2 to config1\n */\nexport default function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  const config = {};\n\n  function getMergedValue(target, source, prop, caseless) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge.call({caseless}, target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(a, b, prop , caseless) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(a, b, prop , caseless);\n    } else if (!utils.isUndefined(a)) {\n      return getMergedValue(undefined, a, prop , caseless);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(a, b) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(a, b) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    } else if (!utils.isUndefined(a)) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(a, b, prop) {\n    if (prop in config2) {\n      return getMergedValue(a, b);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  const mergeMap = {\n    url: valueFromConfig2,\n    method: valueFromConfig2,\n    data: valueFromConfig2,\n    baseURL: defaultToConfig2,\n    transformRequest: defaultToConfig2,\n    transformResponse: defaultToConfig2,\n    paramsSerializer: defaultToConfig2,\n    timeout: defaultToConfig2,\n    timeoutMessage: defaultToConfig2,\n    withCredentials: defaultToConfig2,\n    withXSRFToken: defaultToConfig2,\n    adapter: defaultToConfig2,\n    responseType: defaultToConfig2,\n    xsrfCookieName: defaultToConfig2,\n    xsrfHeaderName: defaultToConfig2,\n    onUploadProgress: defaultToConfig2,\n    onDownloadProgress: defaultToConfig2,\n    decompress: defaultToConfig2,\n    maxContentLength: defaultToConfig2,\n    maxBodyLength: defaultToConfig2,\n    beforeRedirect: defaultToConfig2,\n    transport: defaultToConfig2,\n    httpAgent: defaultToConfig2,\n    httpsAgent: defaultToConfig2,\n    cancelToken: defaultToConfig2,\n    socketPath: defaultToConfig2,\n    responseEncoding: defaultToConfig2,\n    validateStatus: mergeDirectKeys,\n    headers: (a, b , prop) => mergeDeepProperties(headersToObject(a), headersToObject(b),prop, true)\n  };\n\n  utils.forEach(Object.keys({...config1, ...config2}), function computeConfigValue(prop) {\n    const merge = mergeMap[prop] || mergeDeepProperties;\n    const configValue = merge(config1[prop], config2[prop], prop);\n    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n}\n","import platform from \"../platform/index.js\";\nimport utils from \"../utils.js\";\nimport isURLSameOrigin from \"./isURLSameOrigin.js\";\nimport cookies from \"./cookies.js\";\nimport buildFullPath from \"../core/buildFullPath.js\";\nimport mergeConfig from \"../core/mergeConfig.js\";\nimport AxiosHeaders from \"../core/AxiosHeaders.js\";\nimport buildURL from \"./buildURL.js\";\n\nexport default (config) => {\n  const newConfig = mergeConfig({}, config);\n\n  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;\n\n  newConfig.headers = headers = AxiosHeaders.from(headers);\n\n  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);\n\n  // HTTP basic authentication\n  if (auth) {\n    headers.set('Authorization', 'Basic ' +\n      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))\n    );\n  }\n\n  let contentType;\n\n  if (utils.isFormData(data)) {\n    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {\n      headers.setContentType(undefined); // Let the browser set it\n    } else if ((contentType = headers.getContentType()) !== false) {\n      // fix semicolon duplication issue for ReactNative FormData implementation\n      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];\n      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));\n    }\n  }\n\n  // Add xsrf header\n  // This is only done if running in a standard browser environment.\n  // Specifically not if we're in a web worker, or react-native.\n\n  if (platform.hasStandardBrowserEnv) {\n    withXSRFToken && utils.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));\n\n    if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {\n      // Add xsrf header\n      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);\n\n      if (xsrfValue) {\n        headers.set(xsrfHeaderName, xsrfValue);\n      }\n    }\n  }\n\n  return newConfig;\n}\n\n","import utils from './../utils.js';\nimport settle from './../core/settle.js';\nimport transitionalDefaults from '../defaults/transitional.js';\nimport AxiosError from '../core/AxiosError.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport parseProtocol from '../helpers/parseProtocol.js';\nimport platform from '../platform/index.js';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport {progressEventReducer} from '../helpers/progressEventReducer.js';\nimport resolveConfig from \"../helpers/resolveConfig.js\";\n\nconst isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';\n\nexport default isXHRAdapterSupported && function (config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    const _config = resolveConfig(config);\n    let requestData = _config.data;\n    const requestHeaders = AxiosHeaders.from(_config.headers).normalize();\n    let {responseType, onUploadProgress, onDownloadProgress} = _config;\n    let onCanceled;\n    let uploadThrottled, downloadThrottled;\n    let flushUpload, flushDownload;\n\n    function done() {\n      flushUpload && flushUpload(); // flush events\n      flushDownload && flushDownload(); // flush events\n\n      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);\n\n      _config.signal && _config.signal.removeEventListener('abort', onCanceled);\n    }\n\n    let request = new XMLHttpRequest();\n\n    request.open(_config.method.toUpperCase(), _config.url, true);\n\n    // Set the request timeout in MS\n    request.timeout = _config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      const responseHeaders = AxiosHeaders.from(\n        'getAllResponseHeaders' in request && request.getAllResponseHeaders()\n      );\n      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?\n        request.responseText : request.response;\n      const response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config,\n        request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';\n      const transitional = _config.transitional || transitionalDefaults;\n      if (_config.timeoutErrorMessage) {\n        timeoutErrorMessage = _config.timeoutErrorMessage;\n      }\n      reject(new AxiosError(\n        timeoutErrorMessage,\n        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n        config,\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Remove Content-Type if data is undefined\n    requestData === undefined && requestHeaders.setContentType(null);\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {\n        request.setRequestHeader(key, val);\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(_config.withCredentials)) {\n      request.withCredentials = !!_config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = _config.responseType;\n    }\n\n    // Handle progress if needed\n    if (onDownloadProgress) {\n      ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));\n      request.addEventListener('progress', downloadThrottled);\n    }\n\n    // Not all browsers support upload events\n    if (onUploadProgress && request.upload) {\n      ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));\n\n      request.upload.addEventListener('progress', uploadThrottled);\n\n      request.upload.addEventListener('loadend', flushUpload);\n    }\n\n    if (_config.cancelToken || _config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = cancel => {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);\n        request.abort();\n        request = null;\n      };\n\n      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);\n      if (_config.signal) {\n        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    const protocol = parseProtocol(_config.url);\n\n    if (protocol && platform.protocols.indexOf(protocol) === -1) {\n      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));\n      return;\n    }\n\n\n    // Send the request\n    request.send(requestData || null);\n  });\n}\n","'use strict';\n\nexport default function parseProtocol(url) {\n  const match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n  return match && match[1] || '';\n}\n","import CanceledError from \"../cancel/CanceledError.js\";\nimport AxiosError from \"../core/AxiosError.js\";\nimport utils from '../utils.js';\n\nconst composeSignals = (signals, timeout) => {\n  const {length} = (signals = signals ? signals.filter(Boolean) : []);\n\n  if (timeout || length) {\n    let controller = new AbortController();\n\n    let aborted;\n\n    const onabort = function (reason) {\n      if (!aborted) {\n        aborted = true;\n        unsubscribe();\n        const err = reason instanceof Error ? reason : this.reason;\n        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));\n      }\n    }\n\n    let timer = timeout && setTimeout(() => {\n      timer = null;\n      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT))\n    }, timeout)\n\n    const unsubscribe = () => {\n      if (signals) {\n        timer && clearTimeout(timer);\n        timer = null;\n        signals.forEach(signal => {\n          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);\n        });\n        signals = null;\n      }\n    }\n\n    signals.forEach((signal) => signal.addEventListener('abort', onabort));\n\n    const {signal} = controller;\n\n    signal.unsubscribe = () => utils.asap(unsubscribe);\n\n    return signal;\n  }\n}\n\nexport default composeSignals;\n","\nexport const streamChunk = function* (chunk, chunkSize) {\n  let len = chunk.byteLength;\n\n  if (!chunkSize || len < chunkSize) {\n    yield chunk;\n    return;\n  }\n\n  let pos = 0;\n  let end;\n\n  while (pos < len) {\n    end = pos + chunkSize;\n    yield chunk.slice(pos, end);\n    pos = end;\n  }\n}\n\nexport const readBytes = async function* (iterable, chunkSize) {\n  for await (const chunk of readStream(iterable)) {\n    yield* streamChunk(chunk, chunkSize);\n  }\n}\n\nconst readStream = async function* (stream) {\n  if (stream[Symbol.asyncIterator]) {\n    yield* stream;\n    return;\n  }\n\n  const reader = stream.getReader();\n  try {\n    for (;;) {\n      const {done, value} = await reader.read();\n      if (done) {\n        break;\n      }\n      yield value;\n    }\n  } finally {\n    await reader.cancel();\n  }\n}\n\nexport const trackStream = (stream, chunkSize, onProgress, onFinish) => {\n  const iterator = readBytes(stream, chunkSize);\n\n  let bytes = 0;\n  let done;\n  let _onFinish = (e) => {\n    if (!done) {\n      done = true;\n      onFinish && onFinish(e);\n    }\n  }\n\n  return new ReadableStream({\n    async pull(controller) {\n      try {\n        const {done, value} = await iterator.next();\n\n        if (done) {\n         _onFinish();\n          controller.close();\n          return;\n        }\n\n        let len = value.byteLength;\n        if (onProgress) {\n          let loadedBytes = bytes += len;\n          onProgress(loadedBytes);\n        }\n        controller.enqueue(new Uint8Array(value));\n      } catch (err) {\n        _onFinish(err);\n        throw err;\n      }\n    },\n    cancel(reason) {\n      _onFinish(reason);\n      return iterator.return();\n    }\n  }, {\n    highWaterMark: 2\n  })\n}\n","import platform from \"../platform/index.js\";\nimport utils from \"../utils.js\";\nimport AxiosError from \"../core/AxiosError.js\";\nimport composeSignals from \"../helpers/composeSignals.js\";\nimport {trackStream} from \"../helpers/trackStream.js\";\nimport AxiosHeaders from \"../core/AxiosHeaders.js\";\nimport {progressEventReducer, progressEventDecorator, asyncDecorator} from \"../helpers/progressEventReducer.js\";\nimport resolveConfig from \"../helpers/resolveConfig.js\";\nimport settle from \"../core/settle.js\";\n\nconst isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';\nconst isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';\n\n// used only inside the fetch adapter\nconst encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?\n    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :\n    async (str) => new Uint8Array(await new Response(str).arrayBuffer())\n);\n\nconst test = (fn, ...args) => {\n  try {\n    return !!fn(...args);\n  } catch (e) {\n    return false\n  }\n}\n\nconst supportsRequestStream = isReadableStreamSupported && test(() => {\n  let duplexAccessed = false;\n\n  const hasContentType = new Request(platform.origin, {\n    body: new ReadableStream(),\n    method: 'POST',\n    get duplex() {\n      duplexAccessed = true;\n      return 'half';\n    },\n  }).headers.has('Content-Type');\n\n  return duplexAccessed && !hasContentType;\n});\n\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\n\nconst supportsResponseStream = isReadableStreamSupported &&\n  test(() => utils.isReadableStream(new Response('').body));\n\n\nconst resolvers = {\n  stream: supportsResponseStream && ((res) => res.body)\n};\n\nisFetchSupported && (((res) => {\n  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {\n    !resolvers[type] && (resolvers[type] = utils.isFunction(res[type]) ? (res) => res[type]() :\n      (_, config) => {\n        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);\n      })\n  });\n})(new Response));\n\nconst getBodyLength = async (body) => {\n  if (body == null) {\n    return 0;\n  }\n\n  if(utils.isBlob(body)) {\n    return body.size;\n  }\n\n  if(utils.isSpecCompliantForm(body)) {\n    const _request = new Request(platform.origin, {\n      method: 'POST',\n      body,\n    });\n    return (await _request.arrayBuffer()).byteLength;\n  }\n\n  if(utils.isArrayBufferView(body) || utils.isArrayBuffer(body)) {\n    return body.byteLength;\n  }\n\n  if(utils.isURLSearchParams(body)) {\n    body = body + '';\n  }\n\n  if(utils.isString(body)) {\n    return (await encodeText(body)).byteLength;\n  }\n}\n\nconst resolveBodyLength = async (headers, body) => {\n  const length = utils.toFiniteNumber(headers.getContentLength());\n\n  return length == null ? getBodyLength(body) : length;\n}\n\nexport default isFetchSupported && (async (config) => {\n  let {\n    url,\n    method,\n    data,\n    signal,\n    cancelToken,\n    timeout,\n    onDownloadProgress,\n    onUploadProgress,\n    responseType,\n    headers,\n    withCredentials = 'same-origin',\n    fetchOptions\n  } = resolveConfig(config);\n\n  responseType = responseType ? (responseType + '').toLowerCase() : 'text';\n\n  let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);\n\n  let request;\n\n  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {\n      composedSignal.unsubscribe();\n  });\n\n  let requestContentLength;\n\n  try {\n    if (\n      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&\n      (requestContentLength = await resolveBodyLength(headers, data)) !== 0\n    ) {\n      let _request = new Request(url, {\n        method: 'POST',\n        body: data,\n        duplex: \"half\"\n      });\n\n      let contentTypeHeader;\n\n      if (utils.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {\n        headers.setContentType(contentTypeHeader)\n      }\n\n      if (_request.body) {\n        const [onProgress, flush] = progressEventDecorator(\n          requestContentLength,\n          progressEventReducer(asyncDecorator(onUploadProgress))\n        );\n\n        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);\n      }\n    }\n\n    if (!utils.isString(withCredentials)) {\n      withCredentials = withCredentials ? 'include' : 'omit';\n    }\n\n    // Cloudflare Workers throws when credentials are defined\n    // see https://github.com/cloudflare/workerd/issues/902\n    const isCredentialsSupported = \"credentials\" in Request.prototype;\n    request = new Request(url, {\n      ...fetchOptions,\n      signal: composedSignal,\n      method: method.toUpperCase(),\n      headers: headers.normalize().toJSON(),\n      body: data,\n      duplex: \"half\",\n      credentials: isCredentialsSupported ? withCredentials : undefined\n    });\n\n    let response = await fetch(request, fetchOptions);\n\n    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');\n\n    if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {\n      const options = {};\n\n      ['status', 'statusText', 'headers'].forEach(prop => {\n        options[prop] = response[prop];\n      });\n\n      const responseContentLength = utils.toFiniteNumber(response.headers.get('content-length'));\n\n      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(\n        responseContentLength,\n        progressEventReducer(asyncDecorator(onDownloadProgress), true)\n      ) || [];\n\n      response = new Response(\n        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {\n          flush && flush();\n          unsubscribe && unsubscribe();\n        }),\n        options\n      );\n    }\n\n    responseType = responseType || 'text';\n\n    let responseData = await resolvers[utils.findKey(resolvers, responseType) || 'text'](response, config);\n\n    !isStreamResponse && unsubscribe && unsubscribe();\n\n    return await new Promise((resolve, reject) => {\n      settle(resolve, reject, {\n        data: responseData,\n        headers: AxiosHeaders.from(response.headers),\n        status: response.status,\n        statusText: response.statusText,\n        config,\n        request\n      })\n    })\n  } catch (err) {\n    unsubscribe && unsubscribe();\n\n    if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {\n      throw Object.assign(\n        new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request),\n        {\n          cause: err.cause || err\n        }\n      )\n    }\n\n    throw AxiosError.from(err, err && err.code, config, request);\n  }\n});\n\n\n","import utils from '../utils.js';\nimport httpAdapter from './http.js';\nimport xhrAdapter from './xhr.js';\nimport fetchAdapter from './fetch.js';\nimport AxiosError from \"../core/AxiosError.js\";\n\nconst knownAdapters = {\n  http: httpAdapter,\n  xhr: xhrAdapter,\n  fetch: fetchAdapter\n}\n\nutils.forEach(knownAdapters, (fn, value) => {\n  if (fn) {\n    try {\n      Object.defineProperty(fn, 'name', {value});\n    } catch (e) {\n      // eslint-disable-next-line no-empty\n    }\n    Object.defineProperty(fn, 'adapterName', {value});\n  }\n});\n\nconst renderReason = (reason) => `- ${reason}`;\n\nconst isResolvedHandle = (adapter) => utils.isFunction(adapter) || adapter === null || adapter === false;\n\nexport default {\n  getAdapter: (adapters) => {\n    adapters = utils.isArray(adapters) ? adapters : [adapters];\n\n    const {length} = adapters;\n    let nameOrAdapter;\n    let adapter;\n\n    const rejectedReasons = {};\n\n    for (let i = 0; i < length; i++) {\n      nameOrAdapter = adapters[i];\n      let id;\n\n      adapter = nameOrAdapter;\n\n      if (!isResolvedHandle(nameOrAdapter)) {\n        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];\n\n        if (adapter === undefined) {\n          throw new AxiosError(`Unknown adapter '${id}'`);\n        }\n      }\n\n      if (adapter) {\n        break;\n      }\n\n      rejectedReasons[id || '#' + i] = adapter;\n    }\n\n    if (!adapter) {\n\n      const reasons = Object.entries(rejectedReasons)\n        .map(([id, state]) => `adapter ${id} ` +\n          (state === false ? 'is not supported by the environment' : 'is not available in the build')\n        );\n\n      let s = length ?\n        (reasons.length > 1 ? 'since :\\n' + reasons.map(renderReason).join('\\n') : ' ' + renderReason(reasons[0])) :\n        'as no adapter specified';\n\n      throw new AxiosError(\n        `There is no suitable adapter to dispatch the request ` + s,\n        'ERR_NOT_SUPPORT'\n      );\n    }\n\n    return adapter;\n  },\n  adapters: knownAdapters\n}\n","// eslint-disable-next-line strict\nexport default null;\n","'use strict';\n\nimport transformData from './transformData.js';\nimport isCancel from '../cancel/isCancel.js';\nimport defaults from '../defaults/index.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport adapters from \"../adapters/adapters.js\";\n\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n *\n * @param {Object} config The config that is to be used for the request\n *\n * @returns {void}\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new CanceledError(null, config);\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n *\n * @returns {Promise} The Promise to be fulfilled\n */\nexport default function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  config.headers = AxiosHeaders.from(config.headers);\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.transformRequest\n  );\n\n  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {\n    config.headers.setContentType('application/x-www-form-urlencoded', false);\n  }\n\n  const adapter = adapters.getAdapter(config.adapter || defaults.adapter);\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      config.transformResponse,\n      response\n    );\n\n    response.headers = AxiosHeaders.from(response.headers);\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          config.transformResponse,\n          reason.response\n        );\n        reason.response.headers = AxiosHeaders.from(reason.response.headers);\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n}\n","export const VERSION = \"1.11.0\";","'use strict';\n\nimport {VERSION} from '../env/data.js';\nimport AxiosError from '../core/AxiosError.js';\n\nconst validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nconst deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n *\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n *\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return (value, opt, opts) => {\n    if (validator === false) {\n      throw new AxiosError(\n        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),\n        AxiosError.ERR_DEPRECATED\n      );\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\nvalidators.spelling = function spelling(correctSpelling) {\n  return (value, opt) => {\n    // eslint-disable-next-line no-console\n    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);\n    return true;\n  }\n};\n\n/**\n * Assert object's properties type\n *\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n *\n * @returns {object}\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);\n  }\n  const keys = Object.keys(options);\n  let i = keys.length;\n  while (i-- > 0) {\n    const opt = keys[i];\n    const validator = schema[opt];\n    if (validator) {\n      const value = options[opt];\n      const result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);\n    }\n  }\n}\n\nexport default {\n  assertOptions,\n  validators\n};\n","'use strict';\n\nimport utils from './../utils.js';\nimport buildURL from '../helpers/buildURL.js';\nimport InterceptorManager from './InterceptorManager.js';\nimport dispatchRequest from './dispatchRequest.js';\nimport mergeConfig from './mergeConfig.js';\nimport buildFullPath from './buildFullPath.js';\nimport validator from '../helpers/validator.js';\nimport AxiosHeaders from './AxiosHeaders.js';\n\nconst validators = validator.validators;\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n *\n * @return {Axios} A new instance of Axios\n */\nclass Axios {\n  constructor(instanceConfig) {\n    this.defaults = instanceConfig || {};\n    this.interceptors = {\n      request: new InterceptorManager(),\n      response: new InterceptorManager()\n    };\n  }\n\n  /**\n   * Dispatch a request\n   *\n   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n   * @param {?Object} config\n   *\n   * @returns {Promise} The Promise to be fulfilled\n   */\n  async request(configOrUrl, config) {\n    try {\n      return await this._request(configOrUrl, config);\n    } catch (err) {\n      if (err instanceof Error) {\n        let dummy = {};\n\n        Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());\n\n        // slice off the Error: ... line\n        const stack = dummy.stack ? dummy.stack.replace(/^.+\\n/, '') : '';\n        try {\n          if (!err.stack) {\n            err.stack = stack;\n            // match without the 2 top stack lines\n          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\\n.+\\n/, ''))) {\n            err.stack += '\\n' + stack\n          }\n        } catch (e) {\n          // ignore the case where \"stack\" is an un-writable property\n        }\n      }\n\n      throw err;\n    }\n  }\n\n  _request(configOrUrl, config) {\n    /*eslint no-param-reassign:0*/\n    // Allow for axios('example/url'[, config]) a la fetch API\n    if (typeof configOrUrl === 'string') {\n      config = config || {};\n      config.url = configOrUrl;\n    } else {\n      config = configOrUrl || {};\n    }\n\n    config = mergeConfig(this.defaults, config);\n\n    const {transitional, paramsSerializer, headers} = config;\n\n    if (transitional !== undefined) {\n      validator.assertOptions(transitional, {\n        silentJSONParsing: validators.transitional(validators.boolean),\n        forcedJSONParsing: validators.transitional(validators.boolean),\n        clarifyTimeoutError: validators.transitional(validators.boolean)\n      }, false);\n    }\n\n    if (paramsSerializer != null) {\n      if (utils.isFunction(paramsSerializer)) {\n        config.paramsSerializer = {\n          serialize: paramsSerializer\n        }\n      } else {\n        validator.assertOptions(paramsSerializer, {\n          encode: validators.function,\n          serialize: validators.function\n        }, true);\n      }\n    }\n\n    // Set config.allowAbsoluteUrls\n    if (config.allowAbsoluteUrls !== undefined) {\n      // do nothing\n    } else if (this.defaults.allowAbsoluteUrls !== undefined) {\n      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;\n    } else {\n      config.allowAbsoluteUrls = true;\n    }\n\n    validator.assertOptions(config, {\n      baseUrl: validators.spelling('baseURL'),\n      withXsrfToken: validators.spelling('withXSRFToken')\n    }, true);\n\n    // Set config.method\n    config.method = (config.method || this.defaults.method || 'get').toLowerCase();\n\n    // Flatten headers\n    let contextHeaders = headers && utils.merge(\n      headers.common,\n      headers[config.method]\n    );\n\n    headers && utils.forEach(\n      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n      (method) => {\n        delete headers[method];\n      }\n    );\n\n    config.headers = AxiosHeaders.concat(contextHeaders, headers);\n\n    // filter out skipped interceptors\n    const requestInterceptorChain = [];\n    let synchronousRequestInterceptors = true;\n    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n        return;\n      }\n\n      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    const responseInterceptorChain = [];\n    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    let promise;\n    let i = 0;\n    let len;\n\n    if (!synchronousRequestInterceptors) {\n      const chain = [dispatchRequest.bind(this), undefined];\n      chain.unshift(...requestInterceptorChain);\n      chain.push(...responseInterceptorChain);\n      len = chain.length;\n\n      promise = Promise.resolve(config);\n\n      while (i < len) {\n        promise = promise.then(chain[i++], chain[i++]);\n      }\n\n      return promise;\n    }\n\n    len = requestInterceptorChain.length;\n\n    let newConfig = config;\n\n    i = 0;\n\n    while (i < len) {\n      const onFulfilled = requestInterceptorChain[i++];\n      const onRejected = requestInterceptorChain[i++];\n      try {\n        newConfig = onFulfilled(newConfig);\n      } catch (error) {\n        onRejected.call(this, error);\n        break;\n      }\n    }\n\n    try {\n      promise = dispatchRequest.call(this, newConfig);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    i = 0;\n    len = responseInterceptorChain.length;\n\n    while (i < len) {\n      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);\n    }\n\n    return promise;\n  }\n\n  getUri(config) {\n    config = mergeConfig(this.defaults, config);\n    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);\n    return buildURL(fullPath, config.params, config.paramsSerializer);\n  }\n}\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method,\n      url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n\n  function generateHTTPMethod(isForm) {\n    return function httpMethod(url, data, config) {\n      return this.request(mergeConfig(config || {}, {\n        method,\n        headers: isForm ? {\n          'Content-Type': 'multipart/form-data'\n        } : {},\n        url,\n        data\n      }));\n    };\n  }\n\n  Axios.prototype[method] = generateHTTPMethod();\n\n  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);\n});\n\nexport default Axios;\n","'use strict';\n\nimport CanceledError from './CanceledError.js';\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @param {Function} executor The executor function.\n *\n * @returns {CancelToken}\n */\nclass CancelToken {\n  constructor(executor) {\n    if (typeof executor !== 'function') {\n      throw new TypeError('executor must be a function.');\n    }\n\n    let resolvePromise;\n\n    this.promise = new Promise(function promiseExecutor(resolve) {\n      resolvePromise = resolve;\n    });\n\n    const token = this;\n\n    // eslint-disable-next-line func-names\n    this.promise.then(cancel => {\n      if (!token._listeners) return;\n\n      let i = token._listeners.length;\n\n      while (i-- > 0) {\n        token._listeners[i](cancel);\n      }\n      token._listeners = null;\n    });\n\n    // eslint-disable-next-line func-names\n    this.promise.then = onfulfilled => {\n      let _resolve;\n      // eslint-disable-next-line func-names\n      const promise = new Promise(resolve => {\n        token.subscribe(resolve);\n        _resolve = resolve;\n      }).then(onfulfilled);\n\n      promise.cancel = function reject() {\n        token.unsubscribe(_resolve);\n      };\n\n      return promise;\n    };\n\n    executor(function cancel(message, config, request) {\n      if (token.reason) {\n        // Cancellation has already been requested\n        return;\n      }\n\n      token.reason = new CanceledError(message, config, request);\n      resolvePromise(token.reason);\n    });\n  }\n\n  /**\n   * Throws a `CanceledError` if cancellation has been requested.\n   */\n  throwIfRequested() {\n    if (this.reason) {\n      throw this.reason;\n    }\n  }\n\n  /**\n   * Subscribe to the cancel signal\n   */\n\n  subscribe(listener) {\n    if (this.reason) {\n      listener(this.reason);\n      return;\n    }\n\n    if (this._listeners) {\n      this._listeners.push(listener);\n    } else {\n      this._listeners = [listener];\n    }\n  }\n\n  /**\n   * Unsubscribe from the cancel signal\n   */\n\n  unsubscribe(listener) {\n    if (!this._listeners) {\n      return;\n    }\n    const index = this._listeners.indexOf(listener);\n    if (index !== -1) {\n      this._listeners.splice(index, 1);\n    }\n  }\n\n  toAbortSignal() {\n    const controller = new AbortController();\n\n    const abort = (err) => {\n      controller.abort(err);\n    };\n\n    this.subscribe(abort);\n\n    controller.signal.unsubscribe = () => this.unsubscribe(abort);\n\n    return controller.signal;\n  }\n\n  /**\n   * Returns an object that contains a new `CancelToken` and a function that, when called,\n   * cancels the `CancelToken`.\n   */\n  static source() {\n    let cancel;\n    const token = new CancelToken(function executor(c) {\n      cancel = c;\n    });\n    return {\n      token,\n      cancel\n    };\n  }\n}\n\nexport default CancelToken;\n","const HttpStatusCode = {\n  Continue: 100,\n  SwitchingProtocols: 101,\n  Processing: 102,\n  EarlyHints: 103,\n  Ok: 200,\n  Created: 201,\n  Accepted: 202,\n  NonAuthoritativeInformation: 203,\n  NoContent: 204,\n  ResetContent: 205,\n  PartialContent: 206,\n  MultiStatus: 207,\n  AlreadyReported: 208,\n  ImUsed: 226,\n  MultipleChoices: 300,\n  MovedPermanently: 301,\n  Found: 302,\n  SeeOther: 303,\n  NotModified: 304,\n  UseProxy: 305,\n  Unused: 306,\n  TemporaryRedirect: 307,\n  PermanentRedirect: 308,\n  BadRequest: 400,\n  Unauthorized: 401,\n  PaymentRequired: 402,\n  Forbidden: 403,\n  NotFound: 404,\n  MethodNotAllowed: 405,\n  NotAcceptable: 406,\n  ProxyAuthenticationRequired: 407,\n  RequestTimeout: 408,\n  Conflict: 409,\n  Gone: 410,\n  LengthRequired: 411,\n  PreconditionFailed: 412,\n  PayloadTooLarge: 413,\n  UriTooLong: 414,\n  UnsupportedMediaType: 415,\n  RangeNotSatisfiable: 416,\n  ExpectationFailed: 417,\n  ImATeapot: 418,\n  MisdirectedRequest: 421,\n  UnprocessableEntity: 422,\n  Locked: 423,\n  FailedDependency: 424,\n  TooEarly: 425,\n  UpgradeRequired: 426,\n  PreconditionRequired: 428,\n  TooManyRequests: 429,\n  RequestHeaderFieldsTooLarge: 431,\n  UnavailableForLegalReasons: 451,\n  InternalServerError: 500,\n  NotImplemented: 501,\n  BadGateway: 502,\n  ServiceUnavailable: 503,\n  GatewayTimeout: 504,\n  HttpVersionNotSupported: 505,\n  VariantAlsoNegotiates: 506,\n  InsufficientStorage: 507,\n  LoopDetected: 508,\n  NotExtended: 510,\n  NetworkAuthenticationRequired: 511,\n};\n\nObject.entries(HttpStatusCode).forEach(([key, value]) => {\n  HttpStatusCode[value] = key;\n});\n\nexport default HttpStatusCode;\n","'use strict';\n\nimport utils from './utils.js';\nimport bind from './helpers/bind.js';\nimport Axios from './core/Axios.js';\nimport mergeConfig from './core/mergeConfig.js';\nimport defaults from './defaults/index.js';\nimport formDataToJSON from './helpers/formDataToJSON.js';\nimport CanceledError from './cancel/CanceledError.js';\nimport CancelToken from './cancel/CancelToken.js';\nimport isCancel from './cancel/isCancel.js';\nimport {VERSION} from './env/data.js';\nimport toFormData from './helpers/toFormData.js';\nimport AxiosError from './core/AxiosError.js';\nimport spread from './helpers/spread.js';\nimport isAxiosError from './helpers/isAxiosError.js';\nimport AxiosHeaders from \"./core/AxiosHeaders.js\";\nimport adapters from './adapters/adapters.js';\nimport HttpStatusCode from './helpers/HttpStatusCode.js';\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n *\n * @returns {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  const context = new Axios(defaultConfig);\n  const instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context, {allOwnKeys: true});\n\n  // Copy context to instance\n  utils.extend(instance, context, null, {allOwnKeys: true});\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\n// Create the default instance to be exported\nconst axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Expose Cancel & CancelToken\naxios.CanceledError = CanceledError;\naxios.CancelToken = CancelToken;\naxios.isCancel = isCancel;\naxios.VERSION = VERSION;\naxios.toFormData = toFormData;\n\n// Expose AxiosError class\naxios.AxiosError = AxiosError;\n\n// alias for CanceledError for backward compatibility\naxios.Cancel = axios.CanceledError;\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\n\naxios.spread = spread;\n\n// Expose isAxiosError\naxios.isAxiosError = isAxiosError;\n\n// Expose mergeConfig\naxios.mergeConfig = mergeConfig;\n\naxios.AxiosHeaders = AxiosHeaders;\n\naxios.formToJSON = thing => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);\n\naxios.getAdapter = adapters.getAdapter;\n\naxios.HttpStatusCode = HttpStatusCode;\n\naxios.default = axios;\n\n// this module should only have a default export\nexport default axios\n","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n *\n * @returns {Function}\n */\nexport default function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n}\n","'use strict';\n\nimport utils from './../utils.js';\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n *\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nexport default function isAxiosError(payload) {\n  return utils.isObject(payload) && (payload.isAxiosError === true);\n}\n","import { getAbortController, noop, replaceData, timeUntilStale } from './utils'\nimport { defaultLogger } from './logger'\nimport { notifyManager } from './notifyManager'\nimport { canFetch, createRetryer, isCancelledError } from './retryer'\nimport { Removable } from './removable'\nimport type {\n  CancelOptions,\n  FetchStatus,\n  InitialDataFunction,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport type { QueryObserver } from './queryObserver'\nimport type { Logger } from './logger'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  cache: QueryCache\n  queryKey: TQueryKey\n  queryHash: string\n  logger?: Logger\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = unknown> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: any\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal?: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n  ) => void\n}\n\nexport interface FetchOptions {\n  cancelRefetch?: boolean\n  meta?: any\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: any\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  initialState: QueryState<TData, TError>\n  revertState?: QueryState<TData, TError>\n  state: QueryState<TData, TError>\n  isFetchingOptimistic?: boolean\n\n  private cache: QueryCache\n  private logger: Logger\n  private promise?: Promise<TData>\n  private retryer?: Retryer<TData>\n  private observers: QueryObserver<any, any, any, any, any>[]\n  private defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  private abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.abortSignalConsumed = false\n    this.defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.cache = config.cache\n    this.logger = config.logger || defaultLogger\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.initialState = config.state || getDefaultState(this.options)\n    this.state = this.initialState\n    this.scheduleGc()\n  }\n\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  private setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.defaultOptions, ...options }\n\n    this.updateCacheTime(this.options.cacheTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.promise\n    this.retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some((observer) => observer.options.enabled !== false)\n  }\n\n  isDisabled(): boolean {\n    return this.getObserversCount() > 0 && !this.isActive()\n  }\n\n  isStale(): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      this.observers.some((observer) => observer.getCurrentResult().isStale)\n    )\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n    )\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    if (observer) {\n      observer.refetch({ cancelRefetch: false })\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    if (observer) {\n      observer.refetch({ cancelRefetch: false })\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({ revert: true })\n          } else {\n            this.retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({ silent: true })\n      } else if (this.promise) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.retryer?.continueRetry()\n        // Return current promise if we are already fetching\n        return this.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        this.logger.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = getAbortController()\n\n    // Create query function context\n    const queryFnContext: QueryFunctionContext<TQueryKey> = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta,\n    }\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true\n            return abortController.signal\n          }\n          return undefined\n        },\n      })\n    }\n\n    addSignalProperty(queryFnContext)\n\n    // Create fetch function\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject(\n          `Missing queryFn for queryKey '${this.options.queryHash}'`,\n        )\n      }\n      this.abortSignalConsumed = false\n      return this.options.queryFn(queryFnContext)\n    }\n\n    // Trigger behavior hook\n    const context: FetchContext<TQueryFnData, TError, TData, TQueryKey> = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n    }\n\n    addSignalProperty(context)\n\n    this.options.behavior?.onFetch(context)\n\n    // Store state in case the current fetch needs to be reverted\n    this.revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.cache.config.onError?.(error, this as Query<any, any, any, any>)\n        this.cache.config.onSettled?.(\n          this.state.data,\n          error,\n          this as Query<any, any, any, any>,\n        )\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error)\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      }\n      this.isFetchingOptimistic = false\n    }\n\n    // Try to fetch the data\n    this.retryer = createRetryer({\n      fn: context.fetchFn as () => TData,\n      abort: abortController?.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (typeof data === 'undefined') {\n          if (process.env.NODE_ENV !== 'production') {\n            this.logger.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        this.setData(data as TData)\n\n        // Notify cache callback\n        this.cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.cache.config.onSettled?.(\n          data,\n          this.state.error,\n          this as Query<any, any, any, any>,\n        )\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc()\n        }\n        this.isFetchingOptimistic = false\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n    })\n\n    this.promise = this.retryer.promise\n\n    return this.promise\n  }\n\n  private dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: action.meta ?? null,\n            fetchStatus: canFetch(this.options.networkMode)\n              ? 'fetching'\n              : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading',\n            }),\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error as unknown\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState, fetchStatus: 'idle' }\n          }\n\n          return {\n            ...state,\n            error: error as TError,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error as TError,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate(action)\n      })\n\n      this.cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = typeof data !== 'undefined'\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle',\n  }\n}\n","import { hashQueryKeyByOptions, matchQuery, parseFilterArgs } from './utils'\nimport { Query } from './query'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport type { QueryFilters } from './utils'\nimport type { Action, QueryState } from './query'\nimport type { NotifyEvent, OmitKeyof, QueryKey, QueryOptions } from './types'\nimport type { QueryClient } from './queryClient'\nimport type { QueryObserver } from './queryObserver'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  onError?: (error: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSuccess?: (data: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSettled?: (\n    data: unknown | undefined,\n    error: unknown | null,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n}\n\ninterface QueryHashMap {\n  [hash: string]: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryAdded extends NotifyEvent {\n  type: 'added'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryRemoved extends NotifyEvent {\n  type: 'removed'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryUpdated extends NotifyEvent {\n  type: 'updated'\n  query: Query<any, any, any, any>\n  action: Action<any, any>\n}\n\ninterface NotifyEventQueryObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverResultsUpdated extends NotifyEvent {\n  type: 'observerResultsUpdated'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\nexport type QueryCacheNotifyEvent =\n  | NotifyEventQueryAdded\n  | NotifyEventQueryRemoved\n  | NotifyEventQueryUpdated\n  | NotifyEventQueryObserverAdded\n  | NotifyEventQueryObserverRemoved\n  | NotifyEventQueryObserverResultsUpdated\n  | NotifyEventQueryObserverOptionsUpdated\n\ntype QueryCacheListener = (event: QueryCacheNotifyEvent) => void\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  config: QueryCacheConfig\n\n  private queries: Query<any, any, any, any>[]\n  private queriesMap: QueryHashMap\n\n  constructor(config?: QueryCacheConfig) {\n    super()\n    this.config = config || {}\n    this.queries = []\n    this.queriesMap = {}\n  }\n\n  build<TQueryFnData, TError, TData, TQueryKey extends QueryKey>(\n    client: QueryClient,\n    options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    state?: QueryState<TData, TError>,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> {\n    const queryKey = options.queryKey!\n    const queryHash =\n      options.queryHash ?? hashQueryKeyByOptions(queryKey, options)\n    let query = this.get<TQueryFnData, TError, TData, TQueryKey>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any, any, any>): void {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query\n      this.queries.push(query)\n      this.notify({\n        type: 'added',\n        query,\n      })\n    }\n  }\n\n  remove(query: Query<any, any, any, any>): void {\n    const queryInMap = this.queriesMap[query.queryHash]\n\n    if (queryInMap) {\n      query.destroy()\n\n      this.queries = this.queries.filter((x) => x !== query)\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash]\n      }\n\n      this.notify({ type: 'removed', query })\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach((query) => {\n        this.remove(query)\n      })\n    })\n  }\n\n  get<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryHash: string,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> | undefined {\n    return this.queriesMap[queryHash]\n  }\n\n  getAll(): Query[] {\n    return this.queries\n  }\n\n  find<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    filters: QueryFilters,\n  ): Query<TQueryFnData, TError, TData> | undefined\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  find<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    queryKey: QueryKey,\n    filters?: OmitKeyof<QueryFilters, 'queryKey'>,\n  ): Query<TQueryFnData, TError, TData> | undefined\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  find<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    arg1: QueryKey | QueryFilters,\n    arg2?: OmitKeyof<QueryFilters, 'queryKey'>,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const [filters] = parseFilterArgs(arg1, arg2)\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true\n    }\n\n    return this.queries.find((query) => matchQuery(filters, query))\n  }\n\n  findAll(filters?: QueryFilters): Query[]\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  findAll(\n    queryKey?: QueryKey,\n    filters?: OmitKeyof<QueryFilters, 'queryKey'>,\n  ): Query[]\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  findAll(\n    arg1?: QueryKey | QueryFilters,\n    arg2?: OmitKeyof<QueryFilters, 'queryKey'>,\n  ): Query[]\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  findAll(\n    arg1?: QueryKey | QueryFilters,\n    arg2?: OmitKeyof<QueryFilters, 'queryKey'>,\n  ): Query[] {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    return Object.keys(filters).length > 0\n      ? this.queries.filter((query) => matchQuery(filters, query))\n      : this.queries\n  }\n\n  notify(event: QueryCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({ listener }) => {\n        listener(event)\n      })\n    })\n  }\n\n  onFocus(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach((query) => {\n        query.onFocus()\n      })\n    })\n  }\n\n  onOnline(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach((query) => {\n        query.onOnline()\n      })\n    })\n  }\n}\n","import { notifyManager } from './notifyManager'\nimport { Mutation } from './mutation'\nimport { matchMutation, noop } from './utils'\nimport { Subscribable } from './subscribable'\nimport type { MutationObserver } from './mutationObserver'\nimport type { MutationOptions, NotifyEvent } from './types'\nimport type { QueryClient } from './queryClient'\nimport type { Action, MutationState } from './mutation'\nimport type { MutationFilters } from './utils'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSuccess?: (\n    data: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onMutate?: (\n    variables: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: unknown | undefined,\n    error: unknown | null,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n}\n\ninterface NotifyEventMutationAdded extends NotifyEvent {\n  type: 'added'\n  mutation: Mutation<any, any, any, any>\n}\ninterface NotifyEventMutationRemoved extends NotifyEvent {\n  type: 'removed'\n  mutation: Mutation<any, any, any, any>\n}\n\ninterface NotifyEventMutationObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  mutation?: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any, any>\n}\n\ninterface NotifyEventMutationUpdated extends NotifyEvent {\n  type: 'updated'\n  mutation: Mutation<any, any, any, any>\n  action: Action<any, any, any, any>\n}\n\ntype MutationCacheNotifyEvent =\n  | NotifyEventMutationAdded\n  | NotifyEventMutationRemoved\n  | NotifyEventMutationObserverAdded\n  | NotifyEventMutationObserverRemoved\n  | NotifyEventMutationObserverOptionsUpdated\n  | NotifyEventMutationUpdated\n\ntype MutationCacheListener = (event: MutationCacheNotifyEvent) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  config: MutationCacheConfig\n\n  private mutations: Mutation<any, any, any, any>[]\n  private mutationId: number\n  private resuming: Promise<unknown> | undefined\n\n  constructor(config?: MutationCacheConfig) {\n    super()\n    this.config = config || {}\n    this.mutations = []\n    this.mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>,\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey\n        ? client.getMutationDefaults(options.mutationKey)\n        : undefined,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.mutations.push(mutation)\n    this.notify({ type: 'added', mutation })\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    this.mutations = this.mutations.filter((x) => x !== mutation)\n    this.notify({ type: 'removed', mutation })\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.mutations.forEach((mutation) => {\n        this.remove(mutation)\n      })\n    })\n  }\n\n  getAll(): Mutation[] {\n    return this.mutations\n  }\n\n  find<TData = unknown, TError = unknown, TVariables = any, TContext = unknown>(\n    filters: MutationFilters,\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true\n    }\n\n    return this.mutations.find((mutation) => matchMutation(filters, mutation))\n  }\n\n  findAll(filters: MutationFilters): Mutation[] {\n    return this.mutations.filter((mutation) => matchMutation(filters, mutation))\n  }\n\n  notify(event: MutationCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({ listener }) => {\n        listener(event)\n      })\n    })\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    this.resuming = (this.resuming ?? Promise.resolve())\n      .then(() => {\n        const pausedMutations = this.mutations.filter((x) => x.state.isPaused)\n        return notifyManager.batch(() =>\n          pausedMutations.reduce(\n            (promise, mutation) =>\n              promise.then(() => mutation.continue().catch(noop)),\n            Promise.resolve() as Promise<unknown>,\n          ),\n        )\n      })\n      .then(() => {\n        this.resuming = undefined\n      })\n\n    return this.resuming\n  }\n}\n","import type { QueryBehavior } from './query'\n\nimport type {\n  InfiniteData,\n  QueryFunctionContext,\n  QueryOptions,\n  RefetchQueryFilters,\n} from './types'\n\nexport function infiniteQueryBehavior<\n  TQueryFnData,\n  TError,\n  TData,\n>(): QueryBehavior<TQueryFnData, TError, InfiniteData<TData>> {\n  return {\n    onFetch: (context) => {\n      context.fetchFn = () => {\n        const refetchPage: RefetchQueryFilters['refetchPage'] | undefined =\n          context.fetchOptions?.meta?.refetchPage\n        const fetchMore = context.fetchOptions?.meta?.fetchMore\n        const pageParam = fetchMore?.pageParam\n        const isFetchingNextPage = fetchMore?.direction === 'forward'\n        const isFetchingPreviousPage = fetchMore?.direction === 'backward'\n        const oldPages = context.state.data?.pages || []\n        const oldPageParams = context.state.data?.pageParams || []\n        let newPageParams = oldPageParams\n        let cancelled = false\n\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal?.aborted) {\n                cancelled = true\n              } else {\n                context.signal?.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        // Get query function\n        const queryFn =\n          context.options.queryFn ||\n          (() =>\n            Promise.reject(\n              `Missing queryFn for queryKey '${context.options.queryHash}'`,\n            ))\n\n        const buildNewPages = (\n          pages: unknown[],\n          param: unknown,\n          page: unknown,\n          previous?: boolean,\n        ) => {\n          newPageParams = previous\n            ? [param, ...newPageParams]\n            : [...newPageParams, param]\n          return previous ? [page, ...pages] : [...pages, page]\n        }\n\n        // Create function to fetch a page\n        const fetchPage = (\n          pages: unknown[],\n          manual?: boolean,\n          param?: unknown,\n          previous?: boolean,\n        ): Promise<unknown[]> => {\n          if (cancelled) {\n            return Promise.reject('Cancelled')\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages)\n          }\n\n          const queryFnContext: QueryFunctionContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.options.meta,\n          }\n\n          addSignalProperty(queryFnContext)\n\n          const queryFnResult = queryFn(queryFnContext)\n\n          const promise = Promise.resolve(queryFnResult).then((page) =>\n            buildNewPages(pages, param, page, previous),\n          )\n\n          return promise\n        }\n\n        let promise: Promise<unknown[]>\n\n        // Fetch first page?\n        if (!oldPages.length) {\n          promise = fetchPage([])\n        }\n\n        // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getNextPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param)\n        }\n\n        // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getPreviousPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param, true)\n        }\n\n        // Refetch pages\n        else {\n          newPageParams = []\n\n          const manual = typeof context.options.getNextPageParam === 'undefined'\n\n          const shouldFetchFirstPage =\n            refetchPage && oldPages[0]\n              ? refetchPage(oldPages[0], 0, oldPages)\n              : true\n\n          // Fetch first page\n          promise = shouldFetchFirstPage\n            ? fetchPage([], manual, oldPageParams[0])\n            : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]))\n\n          // Fetch remaining pages\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then((pages) => {\n              const shouldFetchNextPage =\n                refetchPage && oldPages[i]\n                  ? refetchPage(oldPages[i], i, oldPages)\n                  : true\n\n              if (shouldFetchNextPage) {\n                const param = manual\n                  ? oldPageParams[i]\n                  : getNextPageParam(context.options, pages)\n                return fetchPage(pages, manual, param)\n              }\n              return Promise.resolve(\n                buildNewPages(pages, oldPageParams[i], oldPages[i]),\n              )\n            })\n          }\n        }\n\n        const finalPromise = promise.then((pages) => ({\n          pages,\n          pageParams: newPageParams,\n        }))\n\n        return finalPromise\n      }\n    },\n  }\n}\n\nexport function getNextPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[],\n): unknown | undefined {\n  return options.getNextPageParam?.(pages[pages.length - 1], pages)\n}\n\nexport function getPreviousPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[],\n): unknown | undefined {\n  return options.getPreviousPageParam?.(pages[0], pages)\n}\n\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasNextPage(\n  options: QueryOptions<any, any, any, any>,\n  pages?: unknown,\n): boolean | undefined {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages)\n    return (\n      typeof nextPageParam !== 'undefined' &&\n      nextPageParam !== null &&\n      nextPageParam !== false\n    )\n  }\n  return\n}\n\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasPreviousPage(\n  options: QueryOptions<any, any, any, any>,\n  pages?: unknown,\n): boolean | undefined {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages)\n    return (\n      typeof previousPageParam !== 'undefined' &&\n      previousPageParam !== null &&\n      previousPageParam !== false\n    )\n  }\n  return\n}\n","import {\n  functionalUpdate,\n  hashQueryKey,\n  hashQueryKeyByOptions,\n  noop,\n  parseFilterArgs,\n  parseQueryArgs,\n  partialMatchKey,\n} from './utils'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\nimport { defaultLogger } from './logger'\nimport type { OmitKeyof } from '@tanstack/query-core'\nimport type { CancelOptions, DefaultedQueryObserverOptions } from './types'\nimport type { Logger } from './logger'\nimport type { QueryState } from './query'\nimport type {\n  DefaultOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  QueryClientConfig,\n  QueryFunction,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  ResetQueryFilters,\n  SetDataOptions,\n  WithRequired,\n} from './types'\nimport type { MutationFilters, QueryFilters, Updater } from './utils'\n\n// TYPES\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: QueryOptions<any, any, any>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  private queryCache: QueryCache\n  private mutationCache: MutationCache\n  private logger: Logger\n  private defaultOptions: DefaultOptions\n  private queryDefaults: QueryDefaults[]\n  private mutationDefaults: MutationDefaults[]\n  private mountCount: number\n  private unsubscribeFocus?: () => void\n  private unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.queryCache = config.queryCache || new QueryCache()\n    this.mutationCache = config.mutationCache || new MutationCache()\n    this.logger = config.logger || defaultLogger\n    this.defaultOptions = config.defaultOptions || {}\n    this.queryDefaults = []\n    this.mutationDefaults = []\n    this.mountCount = 0\n\n    if (process.env.NODE_ENV !== 'production' && config.logger) {\n      this.logger.error(\n        `Passing a custom logger has been deprecated and will be removed in the next major version.`,\n      )\n    }\n  }\n\n  mount(): void {\n    this.mountCount++\n    if (this.mountCount !== 1) return\n\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations()\n        this.queryCache.onFocus()\n      }\n    })\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations()\n        this.queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.mountCount--\n    if (this.mountCount !== 0) return\n\n    this.unsubscribeFocus?.()\n    this.unsubscribeFocus = undefined\n\n    this.unsubscribeOnline?.()\n    this.unsubscribeOnline = undefined\n  }\n\n  isFetching(filters?: QueryFilters): number\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  isFetching(\n    queryKey?: QueryKey,\n    filters?: OmitKeyof<QueryFilters, 'queryKey'>,\n  ): number\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  isFetching(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): number {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    filters.fetchStatus = 'fetching'\n    return this.queryCache.findAll(filters).length\n  }\n\n  isMutating(filters?: MutationFilters): number {\n    return this.mutationCache.findAll({ ...filters, fetching: true }).length\n  }\n\n  getQueryData<TQueryFnData = unknown>(\n    queryKey: QueryKey,\n  ): TQueryFnData | undefined\n  /**\n   * @deprecated This method will accept only queryKey in the next major version.\n   */\n  getQueryData<TQueryFnData = unknown>(\n    queryKey: QueryKey,\n    filters: OmitKeyof<QueryFilters, 'queryKey'>,\n  ): TQueryFnData | undefined\n  /**\n   * @deprecated This method will accept only queryKey in the next major version.\n   */\n  getQueryData<TQueryFnData = unknown>(\n    queryKey: QueryKey,\n    filters?: OmitKeyof<QueryFilters, 'queryKey'>,\n  ): TQueryFnData | undefined {\n    return this.queryCache.find<TQueryFnData>(queryKey, filters)?.state.data\n  }\n\n  ensureQueryData<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: WithRequired<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n  ): Promise<TData>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  ensureQueryData<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: OmitKeyof<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n  ): Promise<TData>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  ensureQueryData<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: OmitKeyof<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey' | 'queryFn'\n    >,\n  ): Promise<TData>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  ensureQueryData<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | WithRequired<\n          FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n          'queryKey'\n        >,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    const cachedData = this.getQueryData<TData>(parsedOptions.queryKey!)\n\n    return cachedData\n      ? Promise.resolve(cachedData)\n      : this.fetchQuery(parsedOptions)\n  }\n\n  getQueriesData<TQueryFnData = unknown>(\n    filters: QueryFilters,\n  ): [QueryKey, TQueryFnData | undefined][]\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  getQueriesData<TQueryFnData = unknown>(\n    queryKey: QueryKey,\n  ): [QueryKey, TQueryFnData | undefined][]\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  getQueriesData<TQueryFnData = unknown>(\n    queryKeyOrFilters: QueryKey | QueryFilters,\n  ): [QueryKey, TQueryFnData | undefined][] {\n    return this.getQueryCache()\n      .findAll(queryKeyOrFilters)\n      .map(({ queryKey, state }) => {\n        const data = state.data as TQueryFnData | undefined\n        return [queryKey, data]\n      })\n  }\n\n  setQueryData<TQueryFnData>(\n    queryKey: QueryKey,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): TQueryFnData | undefined {\n    const query = this.queryCache.find<TQueryFnData>(queryKey)\n    const prevData = query?.state.data\n    const data = functionalUpdate(updater, prevData)\n\n    if (typeof data === 'undefined') {\n      return undefined\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n    return this.queryCache\n      .build(this, defaultedOptions)\n      .setData(data, { ...options, manual: true })\n  }\n\n  setQueriesData<TQueryFnData>(\n    filters: QueryFilters,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][]\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  setQueriesData<TQueryFnData>(\n    queryKey: QueryKey,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][]\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  setQueriesData<TQueryFnData>(\n    queryKeyOrFilters: QueryKey | QueryFilters,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][] {\n    return notifyManager.batch(() =>\n      this.getQueryCache()\n        .findAll(queryKeyOrFilters)\n        .map(({ queryKey }) => [\n          queryKey,\n          this.setQueryData<TQueryFnData>(queryKey, updater, options),\n        ]),\n    )\n  }\n\n  getQueryState<TQueryFnData = unknown, TError = undefined>(\n    queryKey: QueryKey,\n    /**\n     * @deprecated This filters will be removed in the next major version.\n     */\n    filters?: OmitKeyof<QueryFilters, 'queryKey'>,\n  ): QueryState<TQueryFnData, TError> | undefined {\n    return this.queryCache.find<TQueryFnData, TError>(queryKey, filters)?.state\n  }\n\n  removeQueries(filters?: QueryFilters): void\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  removeQueries(\n    queryKey?: QueryKey,\n    filters?: OmitKeyof<QueryFilters, 'queryKey'>,\n  ): void\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  removeQueries(\n    arg1?: QueryKey | QueryFilters,\n    arg2?: OmitKeyof<QueryFilters, 'queryKey'>,\n  ): void {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    const queryCache = this.queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries<TPageData = unknown>(\n    filters?: ResetQueryFilters<TPageData>,\n    options?: ResetOptions,\n  ): Promise<void>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  resetQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: OmitKeyof<ResetQueryFilters<TPageData>, 'queryKey'>,\n    options?: ResetOptions,\n  ): Promise<void>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  resetQueries(\n    arg1?: QueryKey | ResetQueryFilters,\n    arg2?: OmitKeyof<ResetQueryFilters, 'queryKey'> | ResetOptions,\n    arg3?: ResetOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n    const queryCache = this.queryCache\n\n    const refetchFilters: RefetchQueryFilters = {\n      type: 'active',\n      ...filters,\n    }\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset()\n      })\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  cancelQueries(filters?: QueryFilters, options?: CancelOptions): Promise<void>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  cancelQueries(\n    queryKey?: QueryKey,\n    filters?: OmitKeyof<QueryFilters, 'queryKey'>,\n    options?: CancelOptions,\n  ): Promise<void>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  cancelQueries(\n    arg1?: QueryKey | QueryFilters,\n    arg2?: OmitKeyof<QueryFilters, 'queryKey'> | CancelOptions,\n    arg3?: CancelOptions,\n  ): Promise<void> {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3)\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true\n    }\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache\n        .findAll(filters)\n        .map((query) => query.cancel(cancelOptions)),\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries<TPageData = unknown>(\n    filters?: InvalidateQueryFilters<TPageData>,\n    options?: InvalidateOptions,\n  ): Promise<void>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  invalidateQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: OmitKeyof<InvalidateQueryFilters<TPageData>, 'queryKey'>,\n    options?: InvalidateOptions,\n  ): Promise<void>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  invalidateQueries(\n    arg1?: QueryKey | InvalidateQueryFilters,\n    arg2?: OmitKeyof<InvalidateQueryFilters, 'queryKey'> | InvalidateOptions,\n    arg3?: InvalidateOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    return notifyManager.batch(() => {\n      this.queryCache.findAll(filters).forEach((query) => {\n        query.invalidate()\n      })\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve()\n      }\n      const refetchFilters: RefetchQueryFilters = {\n        ...filters,\n        type: filters.refetchType ?? filters.type ?? 'active',\n      }\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  refetchQueries<TPageData = unknown>(\n    filters?: RefetchQueryFilters<TPageData>,\n    options?: RefetchOptions,\n  ): Promise<void>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  refetchQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: OmitKeyof<RefetchQueryFilters<TPageData>, 'queryKey'>,\n    options?: RefetchOptions,\n  ): Promise<void>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  refetchQueries(\n    arg1?: QueryKey | RefetchQueryFilters,\n    arg2?: OmitKeyof<RefetchQueryFilters, 'queryKey'> | RefetchOptions,\n    arg3?: RefetchOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache\n        .findAll(filters)\n        .filter((query) => !query.isDisabled())\n        .map((query) =>\n          query.fetch(undefined, {\n            ...options,\n            cancelRefetch: options?.cancelRefetch ?? true,\n            meta: { refetchPage: filters.refetchPage },\n          }),\n        ),\n    )\n\n    let promise = Promise.all(promises).then(noop)\n\n    if (!options?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: OmitKeyof<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n  ): Promise<TData>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: OmitKeyof<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey' | 'queryFn'\n    >,\n  ): Promise<TData>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  fetchQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | OmitKeyof<\n          FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n          'queryKey'\n        >,\n    arg3?: OmitKeyof<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey' | 'queryFn'\n    >,\n  ): Promise<TData> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(defaultedOptions.staleTime)\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: OmitKeyof<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n  ): Promise<void>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: OmitKeyof<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey' | 'queryFn'\n    >,\n  ): Promise<void>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | OmitKeyof<\n          FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n          'queryKey'\n        >,\n    arg3?: OmitKeyof<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey' | 'queryFn'\n    >,\n  ): Promise<void> {\n    return this.fetchQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: OmitKeyof<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n  ): Promise<InfiniteData<TData>>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: OmitKeyof<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey' | 'queryFn'\n    >,\n  ): Promise<InfiniteData<TData>>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | OmitKeyof<\n          FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n          'queryKey'\n        >,\n    arg3?: OmitKeyof<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey' | 'queryFn'\n    >,\n  ): Promise<InfiniteData<TData>> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    parsedOptions.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData\n    >()\n    return this.fetchQuery(parsedOptions)\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: OmitKeyof<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n  ): Promise<void>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: OmitKeyof<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey' | 'queryFn'\n    >,\n  ): Promise<void>\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | OmitKeyof<\n          FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n          'queryKey'\n        >,\n    arg3?: OmitKeyof<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey' | 'queryFn'\n    >,\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    return this.mutationCache.resumePausedMutations()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.mutationCache\n  }\n\n  getLogger(): Logger {\n    return this.logger\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.defaultOptions = options\n  }\n\n  setQueryDefaults(\n    queryKey: QueryKey,\n    options: QueryObserverOptions<unknown, any, any, any>,\n  ): void {\n    const result = this.queryDefaults.find(\n      (x) => hashQueryKey(queryKey) === hashQueryKey(x.queryKey),\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.queryDefaults.push({ queryKey, defaultOptions: options })\n    }\n  }\n\n  getQueryDefaults(\n    queryKey?: QueryKey,\n  ): QueryObserverOptions<any, any, any, any, any> | undefined {\n    if (!queryKey) {\n      return undefined\n    }\n\n    // Get the first matching defaults\n    const firstMatchingDefaults = this.queryDefaults.find((x) =>\n      partialMatchKey(queryKey, x.queryKey),\n    )\n\n    // Additional checks and error in dev mode\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter((x) =>\n        partialMatchKey(queryKey, x.queryKey),\n      )\n      // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\n          `[QueryClient] Several query defaults match with key '${JSON.stringify(\n            queryKey,\n          )}'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.`,\n        )\n      }\n    }\n\n    return firstMatchingDefaults?.defaultOptions\n  }\n\n  setMutationDefaults(\n    mutationKey: MutationKey,\n    options: MutationObserverOptions<any, any, any, any>,\n  ): void {\n    const result = this.mutationDefaults.find(\n      (x) => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey),\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.mutationDefaults.push({ mutationKey, defaultOptions: options })\n    }\n  }\n\n  getMutationDefaults(\n    mutationKey?: MutationKey,\n  ): MutationObserverOptions<any, any, any, any> | undefined {\n    if (!mutationKey) {\n      return undefined\n    }\n\n    // Get the first matching defaults\n    const firstMatchingDefaults = this.mutationDefaults.find((x) =>\n      partialMatchKey(mutationKey, x.mutationKey),\n    )\n\n    // Additional checks and error in dev mode\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter((x) =>\n        partialMatchKey(mutationKey, x.mutationKey),\n      )\n      // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\n          `[QueryClient] Several mutation defaults match with key '${JSON.stringify(\n            mutationKey,\n          )}'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.`,\n        )\n      }\n    }\n\n    return firstMatchingDefaults?.defaultOptions\n  }\n\n  defaultQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey extends QueryKey,\n  >(\n    options?:\n      | QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n      | DefaultedQueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >,\n  ): DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n    if (options?._defaulted) {\n      return options as DefaultedQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >\n    }\n\n    const defaultedOptions = {\n      ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options?.queryKey),\n      ...options,\n      _defaulted: true,\n    }\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions,\n      )\n    }\n\n    // dependent default values\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect =\n        defaultedOptions.networkMode !== 'always'\n    }\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense\n    }\n\n    return defaultedOptions as DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T,\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options?.mutationKey),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.queryCache.clear()\n    this.mutationCache.clear()\n  }\n}\n","import { isServer, isValidTimeout } from './utils'\n\nexport abstract class Removable {\n  cacheTime!: number\n  private gcTimeout?: ReturnType<typeof setTimeout>\n\n  destroy(): void {\n    this.clearGcTimeout()\n  }\n\n  protected scheduleGc(): void {\n    this.clearGcTimeout()\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove()\n      }, this.cacheTime)\n    }\n  }\n\n  protected updateCacheTime(newCacheTime: number | undefined): void {\n    // Default to 5 minutes (Infinity for server-side) if no cache time is set\n    this.cacheTime = Math.max(\n      this.cacheTime || 0,\n      newCacheTime ?? (isServer ? Infinity : 5 * 60 * 1000),\n    )\n  }\n\n  protected clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout)\n      this.gcTimeout = undefined\n    }\n  }\n\n  protected abstract optionalRemove(): void\n}\n","import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { sleep } from './utils'\nimport type { CancelOptions, NetworkMode } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = unknown> {\n  fn: () => TData | Promise<TData>\n  abort?: () => void\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => Promise<unknown>\n  cancelRetry: () => void\n  continueRetry: () => void\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError> = (\n  failureCount: number,\n  error: TError,\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = unknown> = (\n  failureCount: number,\n  error: TError,\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = unknown>(\n  config: RetryerConfig<TData, TError>,\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let isResolved = false\n  let continueFn: ((value?: unknown) => boolean) | undefined\n  let promiseResolve: (data: TData) => void\n  let promiseReject: (error: TError) => void\n\n  const promise = new Promise<TData>((outerResolve, outerReject) => {\n    promiseResolve = outerResolve\n    promiseReject = outerReject\n  })\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions))\n\n      config.abort?.()\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const shouldPause = () =>\n    !focusManager.isFocused() ||\n    (config.networkMode !== 'always' && !onlineManager.isOnline())\n\n  const resolve = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onSuccess?.(value)\n      continueFn?.()\n      promiseResolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onError?.(value)\n      continueFn?.()\n      promiseReject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        const canContinue = isResolved || !shouldPause()\n        if (canContinue) {\n          continueResolve(value)\n        }\n        return canContinue\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // Execute query\n    try {\n      promiseOrValue = config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch((error) => {\n        // Stop if the fetch is already resolved\n        if (isResolved) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? 3\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            if (shouldPause()) {\n              return pause()\n            }\n            return\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  // Start loop\n  if (canFetch(config.networkMode)) {\n    run()\n  } else {\n    pause().then(run)\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn?.()\n      return didContinue ? promise : Promise.resolve()\n    },\n    cancelRetry,\n    continueRetry,\n  }\n}\n","import type { Mutation } from './mutation'\nimport type { Query } from './query'\nimport type {\n  FetchStatus,\n  MutationFunction,\n  MutationKey,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryOptions,\n} from './types'\n\n// TYPES\n\nexport interface QueryFilters {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: QueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (mutation: Mutation<any, any, any>) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Include or exclude fetching mutations\n   */\n  fetching?: boolean\n}\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined' || 'Deno' in window\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function difference<T>(array1: T[], array2: T[]): T[] {\n  return array1.filter((x) => !array2.includes(x))\n}\n\nexport function replaceAt<T>(array: T[], index: number, value: T): T[] {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function parseQueryArgs<\n  TOptions extends QueryOptions<any, any, any, TQueryKey>,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | TOptions,\n  arg2?: QueryFunction<any, TQueryKey> | TOptions,\n  arg3?: TOptions,\n): TOptions {\n  if (!isQueryKey(arg1)) {\n    return arg1 as TOptions\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3, queryKey: arg1, queryFn: arg2 } as TOptions\n  }\n\n  return { ...arg2, queryKey: arg1 } as TOptions\n}\n\nexport function parseMutationArgs<\n  TOptions extends MutationOptions<any, any, any, any>,\n>(\n  arg1: MutationKey | MutationFunction<any, any> | TOptions,\n  arg2?: MutationFunction<any, any> | TOptions,\n  arg3?: TOptions,\n): TOptions {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3, mutationKey: arg1, mutationFn: arg2 } as TOptions\n    }\n    return { ...arg2, mutationKey: arg1 } as TOptions\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2, mutationFn: arg1 } as TOptions\n  }\n\n  return { ...arg1 } as TOptions\n}\n\nexport function parseFilterArgs<\n  TFilters extends QueryFilters,\n  TOptions = unknown,\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions,\n): [TFilters, TOptions | undefined] {\n  return (\n    isQueryKey(arg1) ? [{ ...arg2, queryKey: arg1 }, arg3] : [arg1 || {}, arg2]\n  ) as [TFilters, TOptions]\n}\n\nexport function parseMutationFilterArgs<\n  TFilters extends MutationFilters,\n  TOptions = unknown,\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions,\n): [TFilters, TOptions | undefined] {\n  return (\n    isQueryKey(arg1)\n      ? [{ ...arg2, mutationKey: arg1 }, arg3]\n      : [arg1 || {}, arg2]\n  ) as [TFilters, TOptions]\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>,\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (\n    typeof fetchStatus !== 'undefined' &&\n    fetchStatus !== query.state.fetchStatus\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>,\n): boolean {\n  const { exact, fetching, predicate, mutationKey } = filters\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (\n        hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)\n      ) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (\n    typeof fetching === 'boolean' &&\n    (mutation.state.status === 'loading') !== fetching\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: QueryOptions<any, any, any, TQueryKey>,\n): string {\n  const hashFn = options?.queryKeyHashFn || hashQueryKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashQueryKey(queryKey: QueryKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean {\n  return partialDeepEqual(a, b)\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\nexport function shallowEqualObjects<T>(a: T, b: T): boolean {\n  if ((a && !b) || (b && !a)) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function isQueryKey(value: unknown): value is QueryKey {\n  return Array.isArray(value)\n}\n\nexport function isError(value: any): value is Error {\n  return value instanceof Error\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout)\n  })\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nexport function scheduleMicrotask(callback: () => void) {\n  sleep(0).then(callback)\n}\n\nexport function getAbortController(): AbortController | undefined {\n  if (typeof AbortController === 'function') {\n    return new AbortController()\n  }\n  return\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>,\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual?.(prevData, data)) {\n    return prevData as TData\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data)\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n","'use client'\n// Temporary workaround due to an issue with react-native uSES - https://github.com/TanStack/query/pull/3601\nimport { useSyncExternalStore as uSES } from 'use-sync-external-store/shim/index.js'\n\nexport const useSyncExternalStore = uSES\n","'use client'\nimport * as React from 'react'\n\nimport type { QueryClient } from '@tanstack/query-core'\nimport type { ContextOptions } from './types'\n\ndeclare global {\n  interface Window {\n    ReactQueryClientContext?: React.Context<QueryClient | undefined>\n  }\n}\n\nexport const defaultContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\nconst QueryClientSharingContext = React.createContext<boolean>(false)\n\n// If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\nfunction getQueryClientContext(\n  context: React.Context<QueryClient | undefined> | undefined,\n  contextSharing: boolean,\n) {\n  if (context) {\n    return context\n  }\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext\n    }\n\n    return window.ReactQueryClientContext\n  }\n\n  return defaultContext\n}\n\nexport const useQueryClient = ({ context }: ContextOptions = {}) => {\n  const queryClient = React.useContext(\n    getQueryClientContext(context, React.useContext(QueryClientSharingContext)),\n  )\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return queryClient\n}\n\ntype QueryClientProviderPropsBase = {\n  client: QueryClient\n  children?: React.ReactNode\n}\ntype QueryClientProviderPropsWithContext = ContextOptions & {\n  contextSharing?: never\n} & QueryClientProviderPropsBase\ntype QueryClientProviderPropsWithContextSharing = {\n  context?: never\n  contextSharing?: boolean\n} & QueryClientProviderPropsBase\n\nexport type QueryClientProviderProps =\n  | QueryClientProviderPropsWithContext\n  | QueryClientProviderPropsWithContextSharing\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n  context,\n  contextSharing = false,\n}: QueryClientProviderProps): JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  if (process.env.NODE_ENV !== 'production' && contextSharing) {\n    client\n      .getLogger()\n      .error(\n        `The contextSharing option has been deprecated and will be removed in the next major version`,\n      )\n  }\n\n  const Context = getQueryClientContext(context, contextSharing)\n\n  return (\n    <QueryClientSharingContext.Provider value={!context && contextSharing}>\n      <Context.Provider value={client}>{children}</Context.Provider>\n    </QueryClientSharingContext.Provider>\n  )\n}\n","import { scheduleMicrotask } from './utils'\n\n// TYPES\n\ntype NotifyCallback = () => void\n\ntype NotifyFunction = (callback: () => void) => void\n\ntype BatchNotifyFunction = (callback: () => void) => void\n\ntype BatchCallsCallback<T extends unknown[]> = (...args: T) => void\n\nexport function createNotifyManager() {\n  let queue: NotifyCallback[] = []\n  let transactions = 0\n  let notifyFn: NotifyFunction = (callback) => {\n    callback()\n  }\n  let batchNotifyFn: BatchNotifyFunction = (callback: () => void) => {\n    callback()\n  }\n\n  const batch = <T>(callback: () => T): T => {\n    let result\n    transactions++\n    try {\n      result = callback()\n    } finally {\n      transactions--\n      if (!transactions) {\n        flush()\n      }\n    }\n    return result\n  }\n\n  const schedule = (callback: NotifyCallback): void => {\n    if (transactions) {\n      queue.push(callback)\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback)\n      })\n    }\n  }\n\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n  const batchCalls = <T extends unknown[]>(\n    callback: BatchCallsCallback<T>,\n  ): BatchCallsCallback<T> => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args)\n      })\n    }\n  }\n\n  const flush = (): void => {\n    const originalQueue = queue\n    queue = []\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback)\n          })\n        })\n      })\n    }\n  }\n\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n  const setNotifyFunction = (fn: NotifyFunction) => {\n    notifyFn = fn\n  }\n\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n  const setBatchNotifyFunction = (fn: BatchNotifyFunction) => {\n    batchNotifyFn = fn\n  }\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction,\n  } as const\n}\n\n// SINGLETON\nexport const notifyManager = createNotifyManager()\n"],"names":["Mutation","Removable","constructor","config","super","this","defaultOptions","mutationId","mutationCache","logger","defaultLogger","observers","state","getDefaultState","setOptions","options","scheduleGc","_objectSpread","updateCacheTime","cacheTime","meta","setState","dispatch","type","addObserver","observer","includes","push","clearGcTimeout","notify","mutation","removeObserver","filter","x","optionalRemove","length","status","remove","continue","_this$retryer$continu","_this$retryer","retryer","execute","executeMutation","_this$options$retry","createRetryer","fn","mutationFn","variables","Promise","reject","onFail","failureCount","error","onPause","onContinue","retry","retryDelay","networkMode","promise","restored","_this$mutationCache$c3","_this$mutationCache$c4","_this$options$onSucce","_this$options2","_this$mutationCache$c5","_this$mutationCache$c6","_this$options$onSettl","_this$options3","_this$mutationCache$c","_this$mutationCache$c2","_this$options$onMutat","_this$options","onMutate","call","context","data","onSuccess","onSettled","_this$mutationCache$c7","_this$mutationCache$c8","_this$options$onError","_this$options4","_this$mutationCache$c9","_this$mutationCache$c10","_this$options$onSettl2","_this$options5","onError","undefined","action","failureReason","isPaused","canFetch","reducer","notifyManager","batch","forEach","onMutationUpdate","onlineEvents","OnlineManager","Subscribable","setup","onOnline","isServer","window","addEventListener","listener","event","removeEventListener","onSubscribe","cleanup","setEventListener","onUnsubscribe","_this$cleanup","hasListeners","_this$cleanup2","online","setOnline","listeners","_ref","isOnline","navigator","onLine","onlineManager","console","Set","subscribe","bind","identity","add","delete","size","FocusManager","onFocus","focused","setFocused","isFocused","document","visibilityState","focusManager","MutationObserver","client","bindMethods","updateResult","mutate","reset","_this$currentMutation","prevOptions","defaultMutationOptions","shallowEqualObjects","getMutationCache","currentMutation","_this$currentMutation2","notifyOptions","getCurrentResult","currentResult","mutateOptions","build","isLoading","result","isPending","isSuccess","isError","isIdle","_this$mutateOptions$o","_this$mutateOptions","_this$mutateOptions$o2","_this$mutateOptions2","_this$mutateOptions$o3","_this$mutateOptions3","_this$mutateOptions$o4","_this$mutateOptions4","useMutation","arg1","arg2","arg3","React","queryClient","useSyncExternalStore","onStoreChange","batchCalls","shouldThrowError","useErrorBoundary","noop","_useErrorBoundary","params","QueryObserver","trackedProps","selectError","refetch","currentQuery","shouldFetchOnMount","executeFetch","updateTimers","destroy","shouldFetchOnReconnect","shouldFetchOn","refetchOnReconnect","shouldFetchOnWindowFocus","refetchOnWindowFocus","clearStaleTimeout","clearRefetchInterval","prevQuery","defaultQueryOptions","getQueryCache","query","enabled","Error","queryKey","updateQuery","mounted","shouldFetchOptionally","staleTime","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","currentRefetchInterval","updateRefetchInterval","getOptimisticResult","createResult","optimisticResult","keepPreviousData","placeholderData","isPlaceholderData","shouldAssignObserverCurrentProperties","currentResultOptions","currentResultState","trackResult","trackedResult","Object","keys","key","defineProperty","configurable","enumerable","get","getCurrentQuery","arguments","refetchPage","_objectWithoutProperties","_excluded","fetch","fetchOptimistic","defaultedOptions","isFetchingOptimistic","then","fetchOptions","_fetchOptions$cancelR","cancelRefetch","throwOnError","catch","isStale","isValidTimeout","timeout","timeUntilStale","dataUpdatedAt","staleTimeoutId","setTimeout","_this$options$refetch","refetchInterval","nextInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","clearTimeout","clearInterval","prevResult","prevResultState","prevResultOptions","queryChange","queryInitialState","currentQueryInitialState","prevQueryResult","previousQueryResult","errorUpdatedAt","fetchStatus","isPreviousData","_optimisticResults","fetchOnMount","fetchOptionally","select","selectFn","selectResult","replaceData","process","Date","now","isFetching","isInitialLoading","fetchFailureCount","fetchFailureReason","errorUpdateCount","isFetched","dataUpdateCount","isFetchedAfterMount","isRefetching","isLoadingError","isRefetchError","nextResult","defaultNotifyOptions","cache","shouldNotifyListeners","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","some","typedKey","has","onQueryUpdate","manual","isCancelledError","_ref2","retryOnMount","shouldLoadOnMount","refetchOnMount","field","value","suspense","isStaleByTime","createValue","clearReset","isReset","QueryErrorResetBoundaryContext","useQueryErrorResetBoundary","IsRestoringContext","useIsRestoring","Provider","errorResetBoundary","useClearResetErrorBoundary","getHasError","ensureStaleTime","shouldSuspend","isRestoring","willFetch","useQuery","Observer","ensurePreventErrorBoundaryRetry","unsubscribe","useBaseQuery","thisArg","apply","toString","prototype","getPrototypeOf","iterator","toStringTag","Symbol","kindOf","create","thing","str","slice","toLowerCase","kindOfTest","typeOfTest","isArray","Array","isUndefined","isBuffer","val","isFunction","isArrayBuffer","isString","isNumber","isObject","isPlainObject","isDate","isFile","isBlob","isFileList","isURLSearchParams","isReadableStream","isRequest","isResponse","isHeaders","map","obj","i","l","allOwnKeys","getOwnPropertyNames","len","findKey","_key","_global","globalThis","self","global","isContextDefined","isTypedArray","TypedArray","Uint8Array","isHTMLForm","hasOwnProperty","prop","isRegExp","reduceDescriptors","descriptors","getOwnPropertyDescriptors","reducedDescriptors","descriptor","name","ret","defineProperties","isAsyncFn","_setImmediate","setImmediateSupported","postMessageSupported","setImmediate","token","concat","Math","random","callbacks","source","shift","cb","postMessage","asap","queueMicrotask","nextTick","isFormData","kind","FormData","append","isArrayBufferView","ArrayBuffer","isView","buffer","isBoolean","isEmptyObject","e","isStream","pipe","merge","caseless","assignValue","targetKey","extend","a","b","trim","replace","stripBOM","content","charCodeAt","inherits","superConstructor","props","assign","toFlatObject","sourceObj","destObj","propFilter","merged","endsWith","searchString","position","String","lastIndex","indexOf","toArray","arr","forEachEntry","_iterator","next","done","pair","matchAll","regExp","matches","exec","hasOwnProp","freezeMethods","writable","set","toObjectSet","arrayOrString","delimiter","define","split","toCamelCase","m","p1","p2","toUpperCase","toFiniteNumber","defaultValue","Number","isFinite","isSpecCompliantForm","toJSONObject","stack","visit","target","reducedValue","isThenable","isIterable","AxiosError","message","code","request","response","captureStackTrace","utils","toJSON","description","number","fileName","lineNumber","columnNumber","from","customProps","axiosError","cause","isVisitable","removeBrackets","renderKey","path","dots","join","predicates","test","formData","TypeError","metaTokens","indexes","option","visitor","defaultVisitor","useBlob","Blob","convertValue","toISOString","Buffer","JSON","stringify","isFlatArray","el","index","exposedHelpers","pop","encode","charMap","encodeURIComponent","match","AxiosURLSearchParams","_pairs","toFormData","encoder","_encode","buildURL","url","serialize","serializeFn","serializedParams","hashmarkIndex","handlers","use","fulfilled","rejected","synchronous","runWhen","eject","id","clear","h","silentJSONParsing","forcedJSONParsing","clarifyTimeoutError","isBrowser","classes","URLSearchParams","protocols","hasBrowserEnv","_navigator","hasStandardBrowserEnv","product","hasStandardBrowserWebWorkerEnv","WorkerGlobalScope","importScripts","origin","location","href","platform","buildPath","isNumericKey","isLast","arrayToObject","entries","parsePropPath","defaults","transitional","transitionalDefaults","adapter","transformRequest","headers","contentType","getContentType","hasJSONContentType","isObjectPayload","formDataToJSON","setContentType","helpers","isNode","toURLEncodedForm","formSerializer","_FormData","env","rawValue","parser","parse","stringifySafely","transformResponse","JSONRequested","responseType","strictJSONParsing","ERR_BAD_RESPONSE","xsrfCookieName","xsrfHeaderName","maxContentLength","maxBodyLength","validateStatus","common","method","ignoreDuplicateOf","$internals","normalizeHeader","header","normalizeValue","matchHeaderValue","isHeaderNameFilter","AxiosHeaders","valueOrRewrite","rewrite","setHeader","_value","_header","_rewrite","lHeader","setHeaders","rawHeaders","parsed","line","substring","parseHeaders","dest","entry","tokens","tokensRE","parseTokens","matcher","deleted","deleteHeader","normalize","format","normalized","w","char","formatHeader","_len","targets","asStrings","getSetCookie","first","computed","_len2","_key2","accessor","accessors","defineAccessor","accessorName","methodName","buildAccessors","mapped","headerValue","transformData","fns","isCancel","__CANCEL__","CanceledError","ERR_CANCELED","settle","resolve","ERR_BAD_REQUEST","floor","samplesCount","min","bytes","timestamps","firstSampleTS","head","tail","chunkLength","startedAt","bytesCount","passed","round","freq","lastArgs","timer","timestamp","threshold","invoke","args","flush","progressEventReducer","isDownloadStream","bytesNotified","_speedometer","speedometer","throttle","loaded","total","lengthComputable","progressBytes","rate","progress","estimated","progressEventDecorator","throttled","asyncDecorator","isMSIE","URL","protocol","host","port","userAgent","write","expires","domain","secure","cookie","toGMTString","read","RegExp","decodeURIComponent","buildFullPath","baseURL","requestedURL","allowAbsoluteUrls","isRelativeUrl","relativeURL","combineURLs","headersToObject","mergeConfig","config1","config2","getMergedValue","mergeDeepProperties","valueFromConfig2","defaultToConfig2","mergeDirectKeys","mergeMap","paramsSerializer","timeoutMessage","withCredentials","withXSRFToken","onUploadProgress","onDownloadProgress","decompress","beforeRedirect","transport","httpAgent","httpsAgent","cancelToken","socketPath","responseEncoding","configValue","newConfig","auth","btoa","username","password","unescape","Boolean","isURLSameOrigin","xsrfValue","cookies","XMLHttpRequest","_config","resolveConfig","requestData","requestHeaders","onCanceled","uploadThrottled","downloadThrottled","flushUpload","flushDownload","signal","onloadend","responseHeaders","getAllResponseHeaders","err","responseText","statusText","open","onreadystatechange","readyState","responseURL","onabort","ECONNABORTED","onerror","ERR_NETWORK","ontimeout","timeoutErrorMessage","ETIMEDOUT","setRequestHeader","upload","cancel","abort","aborted","parseProtocol","send","composeSignals","signals","controller","AbortController","reason","streamChunk","chunk","chunkSize","byteLength","end","pos","readBytes","_wrapAsyncGenerator","iterable","_iteratorError","_iteratorAbruptCompletion","_didIteratorError","_step","_asyncIterator","readStream","_awaitAsyncGenerator","_asyncGeneratorDelegate","return","_x","_x2","stream","asyncIterator","reader","getReader","_x3","trackStream","onProgress","onFinish","_onFinish","ReadableStream","pull","close","loadedBytes","enqueue","highWaterMark","isFetchSupported","Request","Response","isReadableStreamSupported","encodeText","TextEncoder","async","arrayBuffer","supportsRequestStream","duplexAccessed","hasContentType","body","duplex","supportsResponseStream","resolvers","res","_","ERR_NOT_SUPPORT","resolveBodyLength","getContentLength","_request","getBodyLength","knownAdapters","http","xhr","xhrAdapter","composedSignal","toAbortSignal","requestContentLength","contentTypeHeader","isCredentialsSupported","credentials","isStreamResponse","responseContentLength","responseData","renderReason","isResolvedHandle","adapters","nameOrAdapter","rejectedReasons","reasons","s","throwIfCancellationRequested","throwIfRequested","dispatchRequest","VERSION","validators","deprecatedWarnings","validator","version","formatMessage","opt","desc","opts","ERR_DEPRECATED","warn","spelling","correctSpelling","assertOptions","schema","allowUnknown","ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","Axios","instanceConfig","interceptors","InterceptorManager","configOrUrl","dummy","boolean","function","baseUrl","withXsrfToken","contextHeaders","requestInterceptorChain","synchronousRequestInterceptors","interceptor","unshift","responseInterceptorChain","chain","onFulfilled","onRejected","getUri","generateHTTPMethod","isForm","CancelToken","executor","resolvePromise","_listeners","onfulfilled","_resolve","splice","c","HttpStatusCode","Continue","SwitchingProtocols","Processing","EarlyHints","Ok","Created","Accepted","NonAuthoritativeInformation","NoContent","ResetContent","PartialContent","MultiStatus","AlreadyReported","ImUsed","MultipleChoices","MovedPermanently","Found","SeeOther","NotModified","UseProxy","Unused","TemporaryRedirect","PermanentRedirect","BadRequest","Unauthorized","PaymentRequired","Forbidden","NotFound","MethodNotAllowed","NotAcceptable","ProxyAuthenticationRequired","RequestTimeout","Conflict","Gone","LengthRequired","PreconditionFailed","PayloadTooLarge","UriTooLong","UnsupportedMediaType","RangeNotSatisfiable","ExpectationFailed","ImATeapot","MisdirectedRequest","UnprocessableEntity","Locked","FailedDependency","TooEarly","UpgradeRequired","PreconditionRequired","TooManyRequests","RequestHeaderFieldsTooLarge","UnavailableForLegalReasons","InternalServerError","NotImplemented","BadGateway","ServiceUnavailable","GatewayTimeout","HttpVersionNotSupported","VariantAlsoNegotiates","InsufficientStorage","LoopDetected","NotExtended","NetworkAuthenticationRequired","axios","createInstance","defaultConfig","instance","Cancel","all","promises","spread","callback","isAxiosError","payload","formToJSON","getAdapter","default","Query","abortSignalConsumed","queryHash","initialState","initialData","hasData","initialDataUpdatedAt","fetchMeta","isInvalidated","setData","newData","updatedAt","setStateOptions","silent","isActive","isDisabled","getObserversCount","_this$retryer2","find","_this$retryer3","revert","cancelRetry","invalidate","_this$options$behavio","_context$fetchOptions","_this$retryer4","continueRetry","queryFn","abortController","getAbortController","queryFnContext","pageParam","addSignalProperty","object","fetchFn","_context$fetchOptions2","behavior","onFetch","revertState","_this$cache$config$on","_this$cache$config","_this$cache$config$on2","_this$cache$config2","_this$cache$config$on3","_this$cache$config3","_this$cache$config$on4","_this$cache$config4","_action$meta","_action$dataUpdatedAt","QueryCache","queries","queriesMap","_options$queryHash","hashQueryKeyByOptions","getLogger","getQueryDefaults","queryInMap","getAll","filters","parseFilterArgs","exact","matchQuery","findAll","MutationCache","mutations","mutationKey","getMutationDefaults","matchMutation","resumePausedMutations","_this$resuming","resuming","pausedMutations","reduce","infiniteQueryBehavior","_context$fetchOptions3","_context$fetchOptions4","_context$state$data","_context$state$data2","fetchMore","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","pages","oldPageParams","pageParams","newPageParams","cancelled","buildNewPages","param","page","previous","fetchPage","_context$signal","_context$signal2","queryFnResult","getNextPageParam","getPreviousPageParam","QueryClient","queryCache","queryDefaults","mutationDefaults","mountCount","mount","unsubscribeFocus","unsubscribeOnline","unmount","_this$unsubscribeFocu","_this$unsubscribeOnli","isMutating","fetching","getQueryData","_this$queryCache$find","ensureQueryData","parsedOptions","parseQueryArgs","cachedData","fetchQuery","getQueriesData","queryKeyOrFilters","setQueryData","updater","prevData","functionalUpdate","setQueriesData","_ref3","getQueryState","_this$queryCache$find2","removeQueries","resetQueries","refetchFilters","refetchQueries","cancelQueries","cancelOptions","invalidateQueries","_filters$refetchType","refetchType","_options$cancelRefetc","prefetchQuery","fetchInfiniteQuery","prefetchInfiniteQuery","getDefaultOptions","setDefaultOptions","setQueryDefaults","hashQueryKey","firstMatchingDefaults","partialMatchKey","setMutationDefaults","_defaulted","gcTimeout","newCacheTime","max","Infinity","defaultRetryDelay","CancelledError","continueFn","promiseResolve","promiseReject","isRetryCancelled","isResolved","outerResolve","outerReject","shouldPause","pause","continueResolve","canContinue","run","promiseOrValue","_config$retry","_config$retryDelay","delay","shouldRetry","sleep","input","isQueryKey","parseMutationArgs","predicate","stale","queryKeyHashFn","sort","partialDeepEqual","replaceEqualDeep","array","isPlainArray","aSize","bItems","bSize","copy","equalItems","o","hasObjectPrototype","ctor","prot","scheduleMicrotask","isDataEqual","structuralSharing","useSyncExternalStore$1","defaultContext","QueryClientSharingContext","getQueryClientContext","contextSharing","ReactQueryClientContext","useQueryClient","QueryClientProvider","Context","queue","transactions","notifyFn","batchNotifyFn","schedule","originalQueue","setNotifyFunction","setBatchNotifyFunction","createNotifyManager"],"sourceRoot":""}